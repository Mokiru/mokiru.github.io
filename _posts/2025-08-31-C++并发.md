---
title: C++ 并发编程实践
date: 2025-07-14 10:00:00 +0800
categories: [C++, 并发]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: C++ 并发编程实践 
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

## 软件并发方式

### 多进程并发

在应用软件内部一种并发方式是，将一个应用软件拆分成多个独立进程同时运行。它们都只含单一线程，非常类似于同时运行浏览器和文字处理软件。这些独立进程可以通过所有常规的进程间通信途径相互传递信息(信号、套接字、文件、管道等)，如下图所示。这种进程间通信普遍存在短处：或设置复杂，或速度慢，甚至二者兼有，因为操作系统往往要在进程之间提供大量防护措施，以免某进程意外改动另一个进程的数据；还有一个短处是运行多个进程的固定开销大，进程的启动花费时间，操作系统必须调配内部资源来管控进程，等等。

![alt text](/assets/img/C++并发/1.3.png)

进程间通信并非一无是处：通常，操作系统在进程间提供额外保护和高级通信机制。这就意味着，比起线程，采用进程更容易编写出安全的并发代码。某些编程环境以进程作为基本构建单元，其并发效果确实一流，譬如为Erlang编程语言准备的环境。

运用独立的进程实现并发，还有一个额外优势——通过网络连接，独立的进程能够在不同的计算机上运行。这样做虽然增加了通信开销，可是只要系统设计精良，此法足以低廉而有效地增强并发力度，改进性能。

### 多线程并发

另一种并发方式是在单一进程内运行多线程，线程非常像轻量级进程：每个线程都独立运行，并能各自执行不同的指令序列。不过，同一进程内的所有线程都能直接访问大部分数据。全局变量依然全局可见，指向对象或数据的指针和引用能在线程间传递。尽管进程间共享内存通常可行，但这种做法设置复杂，往往难以驾驭，原因是同一数据地址在不同进程中不一定相同。单一进程内的两个线程借共享内存通信如下图所示。

![alt text](/assets/img/C++并发/1.4.png)

我们可以启用多个单线程的进程并在进程间通信，也可以在单一进程内发动多个线程而在线程间通信，后者的额外开销更低。因此，即使共享内存带来隐患，主流语言大都青睐以多线程的方式实现并发功能，当中也包括C++。再加上C++本身尚不支持进程间通信，所以采用多进程的应用软件不得不依赖于平台专属的应用程序接口(Application Program Interface, API)。

## 并发与并行

就多线程代码而言，并发与并行(parallel)的含义很大程度上相互重叠。二者差别甚小，主要是着眼点和使用意图不同。两个术语都是指使用可调配的硬件资源同时运行多个任务，但并行更强调性能。当人们谈及并行时，主要关心的是利用可调配的硬件资源提升大规模数据处理的性能；当谈及并发时，主要关心的是分离关注点或响应能力。

## 为什么使用并发

应用软件使用并发技术的主要原因有两个：分离关注点与性能提升。实际上这几乎是仅有的用到并发技术的原因。如果寻根究底，任何其他原因都归结为二者之一，也可能兼有。

### 为分离关注点并发

一直以来，编写软件时，分离关注点(separation of concerns)几乎总是不错的构思：归类相关代码，隔离无关代码，使程序更易于理解和测试，因此所含缺陷很可能更少。并发技术可以用于隔离不同领域的操作，即便这些不同领域的操作需同时进行；若不直接使用并发技术，我们将不得不编写框架做任务切换，或者不得不在某个操作步骤中，频繁调用无关领域的代码。

考虑一个带有用户界面的应用软件，需要由CPU密集处理，如台式计算机上的DVD播放软件。本质上，这个应用软件肩负两大职责：既要从碟片读取数据，解码声音影像，并将其及时传送给图形硬件和音效硬件，让DVD顺畅放映，又要接收用户的操作输入，譬如用户按“暂停”“返回选项单”“退出”等键。假若采取单一线程，则该应用软件在播放过程中，不得不定时检查用户输入，结果会混杂播放DVD的代码与用户界面的代码。改用多线程就可以分离上述两个关注点，一个线程只负责用户界面管理，另一个线程只负责播放DVD，用户界面的代码和播放DVD的代码遂可避免紧密纠缠。两个线程之间还会保留必要的交互，例如按“暂停”键，不过这些交互仅仅与需要立即处理的事件直接关联。

如果用户发送了操作请求，而播放DVD线程正忙，无法马上处理，那么在请求被传送到该线程的同时，代码通常能令用户界面线程立刻做出响应，即便只是显示光标或提示“请稍后”。这种方法使得应用软件看起来响应及时。类似地，某些必须在后台持续工作的任务，则常常交由独立线程负责运行，例如，让桌面搜索应用软件监控文件系统变动。此法基本能大幅简化各线程的内部逻辑，原因是线程间交互得以限定于代码中可明确辨识的切入点，而无须将不同任务的逻辑交错散置。

这样，线程的实际数量便与CPU既有的内核数量无关，因为用线程分离关注点的依据是设计理念，不以增加运算吞吐量为目的。

### 为性能并发：任务并行和数据并行

增强性能的并发方式有两种。第一种，最直观地，将单一任务分解成多个部分，各自并行运作，从而节省总运行耗时。此方法即为任务并行。尽管听起来浅白、直接，但这却有可能涉及相当复杂的处理过程，因为任务各部分之间也许存在纷繁的依赖。任务分解可以针对处理过程，调度某线程运行同一算法的某部分，另一线程则运行其他部分；也可以针对数据，线程分别对数据的不同部分执行同样的操作，这被称为数据并行。

易于采用上述并行方式的算法常常被称为尴尬并行算法。其含义是，将算法的代码并行化实在简单，甚至简单得会让我们尴尬，实际上这是好事。尴尬并行算法具备的优良特性是可按规模伸缩——只要硬件支持的线程数目增加，算法的并行程度就能相应提升。

第二种增强性能的并发方式是利用并行资源解决规模更大的问题。例如，只要条件合适，便同时处理2个文件，或者10个，甚至20个，而不是每次1个。同时对多组数据执行一样的操作，实际上是采用了数据并行，其着眼点有别于任务并行。采用这种方式处理单一数据所需的时间依旧不变，而同等时间内能处理的数据相对更多。

### 什么时候避免并发

知道何时避免并发，与知道何时采用并发同等重要。归根结底，不用并发技术的唯一原因是收益不及代价。多数情况下，采用了并发技术的代码更难理解，编写和维护多线程代码会更劳心费神，并且复杂度增加可能导致更多错误。编写正确运行的多线程代码需要额外的开发时间和相关维护成本，除非潜在的性能提升或因分离关注点而提高的清晰度值得这些开销，否则别使用并发技术。

此外，性能增幅可能不如预期。线程的启动存在固有开销，因为系统须妥善分配相关的内核资源和栈空间，然后才可以往调度器添加新线程，这些都会耗费时间。假如子线程上运行的任务太快完成，处理任务本身的时间就会远短于线程启动的时间，结果，应用程序的整体性能很可能还不如完全由主线程直接执行任务的性能。

再者，线程是一种有限的资源。若因此运行太多线程，便会消耗操作系统资源，可能令系统整体变慢。而且由于每个线程都需要独立的栈空间(指可执行程序在系统运行时，各线程自身专有的内存区域，也分别称为栈数据段和堆数据段，它们有别于数据结构中的栈概念和std栈容器)，如果线程太多，就可能耗尽所属进程的可用内存或地址空间。在采用扁平模式内存架构的32位进程中，可用的地址空间是4GB，这很成问题：假定每个线程栈的大小都是1MB(这个大小常见于许多系统)，那么4096个线程即会把全部地址空间耗尽，使得代码、静态数据和堆数据无地立足。尽管64位系统(或指令集宽度更大的系统)对地址空间的直接限制相对宽松，但其资源依旧有限，运行太多线程仍将带来问题。虽然线程池可用于控制线程数量，但也并非万能妙法，它自身也有局限。

假设，在服务器端，客户端/服务器(Client/Server C/S)模式的应用程序为每个连接发起一个独立的线程。如果只有少量连接，这尚能良好工作。不过，请求量巨大的服务器需要处理的连接数目庞大，若采用同样的方法，就会发起过多线程而很快耗尽系统资源。针对这一情形，如果要达到最优性能，便须谨慎使用线程池。

最后，运行的线程数越多，操作系统所做的上下文切换就越频繁，每一次切换都会减少本该用于实质工作的时间。结果，当线程数目达到一定程度时，再增加新线程只会降低应用软件的整体性能，而不会提升性能，正因如此，应以可用的硬件并发资源作为依据，调整运行线程的数目。

为了提升性能而使用并发技术，与其他优化策略相仿：它极具应用程序性能的潜力，却也可能令代码复杂化，使之更难理解，更容易出错。所以，对于应用程序中涉及性能的关键部分，若其具备提升性能的潜力，收效可观，才值得为之实现并发功能。当然，如果首要目标是设计得清楚明晰或分离关注点，而提升性能居次，也值得采用多线程设计。

