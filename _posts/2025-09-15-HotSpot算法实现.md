---
title: HotSpot算法实现
date: 2025-09-15 10:00:00 +0800
categories: [Java, JVM]
tags: [study]     # TAG names should always be lowercase
author: momochi
description: 
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

前面介绍了常见的对象存活判定算法和垃圾收集算法，Java虚拟机实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。

## 根节点枚举

固定可作为GC Roots的节点主要在全局性的引用(如常量或静态属性)与执行上下文(例如栈帧中的本地变量表)中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越来越大，方法区的大小常有上百上千MB，其中的类若要逐个检查以这里为起源的引用肯定会耗费大量时间。

Serial、ParNew、Parallel、G1收集器在根节点枚举这一步骤时都是必须暂停用户线程的，当前，ZGC、Shenandoah可以并发根扫描。这里先假设都是暂停用户线程的。因此根节点枚举与之前垃圾收集算法中，整理内存碎片一样会面临相似的“Stop The World”困扰。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因。

目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来后，其实不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。

```
Compiled method (c1)      65    9       3       java.lang.String::hashCode (49 bytes)
 total in heap  [0x0000021725da5f90,0x0000021725da6890] = 2304
 relocation     [0x0000021725da6108,0x0000021725da6168] = 96
 main code      [0x0000021725da6180,0x0000021725da6540] = 960
 stub code      [0x0000021725da6540,0x0000021725da6588] = 72
 metadata       [0x0000021725da6588,0x0000021725da65a0] = 24
 scopes data    [0x0000021725da65a0,0x0000021725da6688] = 232
 scopes pcs     [0x0000021725da6688,0x0000021725da6878] = 496
 dependencies   [0x0000021725da6878,0x0000021725da6880] = 8
 nul chk table  [0x0000021725da6880,0x0000021725da6890] = 16
Could not load hsdis-amd64.dll; library not loadable; PrintAssembly is disabled

ImmutableOopMap{[64]=Oop }pc offsets: 468 
ImmutableOopMap{[64]=Oop rdi=Oop }pc offsets: 635 
ImmutableOopMap{rdx=Oop }pc offsets: 771 
ImmutableOopMap{rdx=Oop rdi=Oop }pc offsets: 781 
ImmutableOopMap{rdi=Oop rdx=Oop }pc offsets: 809 
ImmutableOopMap{[64]=Oop rdi=Oop }pc offsets: 842 875 Compiled method (c2)      68   10       4       java.lang.String::hashCode (49 bytes)
 total in heap  [0x000002172d2d1b10,0x000002172d2d1f80] = 1136
 relocation     [0x000002172d2d1c88,0x000002172d2d1cc0] = 56
 main code      [0x000002172d2d1cc0,0x000002172d2d1d80] = 192
 stub code      [0x000002172d2d1d80,0x000002172d2d1dc8] = 72
 metadata       [0x000002172d2d1dc8,0x000002172d2d1dd0] = 8
 scopes data    [0x000002172d2d1dd0,0x000002172d2d1e30] = 96
 scopes pcs     [0x000002172d2d1e30,0x000002172d2d1f20] = 240
 dependencies   [0x000002172d2d1f20,0x000002172d2d1f28] = 8
 handler table  [0x000002172d2d1f28,0x000002172d2d1f70] = 72
 nul chk table  [0x000002172d2d1f70,0x000002172d2d1f80] = 16

ImmutableOopMap{rbp=Oop }pc offsets: 92 112 128 
ImmutableOopMap{}pc offsets: 140 Done. Check logs.
```

上面是HotSpot虚拟机生成的一段`String::hashCode()`方法的本地代码，可以看到有


## 安全点

在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来