---
title: JVM虚拟机
date: 2025-08-16 10:00:00 +0800
categories: [Java]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: JVM虚拟机概述
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

## JVM运行时数据区域(内存结构) & GC

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，

![alt text](/assets/img/jvm/运行时数据区域.png)

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型中，字节码解释器工作时，通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(如果是多核处理器就是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

如果线程正在执行的一个是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值应为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### Java虚拟机栈

和程序计数器一样，Java虚拟机栈也是线程私有的，生命周期与线程相同，虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应一个栈帧入栈出栈的过程。

在局部变量表中，存放了编译器可知的各种Java虚拟机基本数据类型、对象引用和地址。这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小(槽的数量)。

StackOverflowError异常就是线程请求的栈深度大于虚拟机所允许的深度，查看jvm线程栈大小命令如下：

```
java -XX:+PrintFlagsFinal -version | grep ThreadStackSize
java -XX:+PrintFlagsFinal -version | findstr ThreadStackSize
```

结果如下图所示：

![alt text](/assets/img/jvm/ThreadStackSize.png)

其中`{pd ergo}`表示平台默认，通常64位JVM的默认线程栈(虚拟机栈，该说法用来强调每个线程都有自己的栈)大小为1MB。

设置线程栈大小命令如下：

```
java -Xss512k MyApp
```

以下为一个出发StackOverflowError简单示例：

```java
public class StackOverflowDemo {

    // 无限递归函数
    public static void recallMethod() {
        recallMethod();
    }

    public static void main(String[] args) {
        recallMethod();
    }
}
```

OutOfMemoryError则是在无法申请到足够内存时抛出，而在HotSpot虚拟机上，Java虚拟机栈容量是不会动态扩展的，因此只要在线程申请栈空间时成功就不会出现OutOfMemoryError。

由此，我们可以知道线程栈内存大小是在JVM启动时确定的，在HotSpot虚拟机上，虚拟机栈容量不会动态扩展，那么完全可以在不同情况下设置相应的ThreadStackSize来控制线程申请的内存来减少内存消耗。

例如，线程栈大小1MB，如果创建了1000个线程，即使什么都不做，JVM也会预留 $$1000\times 1MB = 1GB$$的虚拟内存。虽然这部分不会立即占用物理内存，但是会增加进程的虚拟地址空间占用，并且可能触发OutOfMemoryError，因为上面说到线程申请内存时失败就会抛出该Error，那么在极端情况下，线程申请不到1MB的时候可能就会出现`OutOfMemoryError: unable to create new native thread`。

因此，我们可以在保证程序正常运行(不触发`StackOverflowError`)的前提下，减小每个线程栈大小，从而降低整体内存占用。相应的，对于深度递归、复杂解析的任务，也可以适当增加线程栈大小来避免触发`StackOverflowError`。

### 本地方法栈

本地方法栈与虚拟机栈发挥的作用是非常相似的，其区别只是虚拟机栈作为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。

虚拟机规范对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机(如HotSpot)直接就把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样，本地方法栈也会在栈深度溢出或栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError。

### 堆

对于Java的应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，Java中几乎所有的对象实例都在这里分配内存，在虚拟机规范中对Java堆的描述是“所有的对象实例以及数组都应当在堆上分配”，而这里的几乎，是因为会有逃逸分析，栈上分配、标量替换优化手段。

Java堆是垃圾收集器管理的内存区域，因此也称为“GC堆”，从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些区域划分仅仅是一部分垃圾收集器的共同特性或者设计风格，而并非某个Java虚拟机具体实现的固有内存布局，更不是虚拟机规范里对Java堆的进一步细分。

从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)，以提升对象分配时的效率。不过，无论从什么角度，怎么划分，都不会改变Java堆中存储内容的共性。存储的都只是对象实例。将Java堆细分只是为了更好地回收内存，或者更快地分配内存。

根据虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象(如数组)，多数虚拟机实现出于简单、存储高效的考虑，很可能要求连续的存储空间。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数-Xmx和-Xms设定)。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机会抛出OutOfMemoryError。

-Xms，设置JVM启动时的初始堆大小。-Xmx设置JVM可扩展到的最大堆大小。

显然，以上两个设置，在只设置一个设置的情况下，可能会出现，例如设置了-Xmx，但是-Xms默认值很小，那么会导致初期频繁Minor GC，扩展的时候出现Full GC。

### 方法区

方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然虚拟机规范中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是和Java堆区分。

方法区和永久代并不是等价的，因为在JDK8之前当时的HotSpot虚拟机设计选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这一部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受虚拟机规范管束。

而使用永久代来实现方法区的设计，导致了Java应用更容易遇到内存溢出的问题(永久代有-XX:MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会有问题)，而且有极少数方法(例如`String:intern()`)会因为永久代的原因导致不同虚拟机下有不同的表现。因此在JDK6的时候HotSpot就有放弃永久代，逐步改为采用本地内存(Native Memory)来实现方法区的计划。JDK7的HotSpot已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来代替，把JDK7中永久代剩下的内容全部移到元空间中。

虚拟机规范对方法区的约束非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确比较少出现，但并非数据进入了方法区就如永久代的名字一样永久存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

根据虚拟机规范规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError。

### 运行时常量池