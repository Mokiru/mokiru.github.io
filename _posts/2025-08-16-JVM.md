---
title: JVM虚拟机
date: 2025-08-16 10:00:00 +0800
categories: [Java]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: JVM虚拟机概述
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

## JVM运行时数据区域(内存结构)

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，

![alt text](/assets/img/jvm/运行时数据区域.png)

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型中，字节码解释器工作时，通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(如果是多核处理器就是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

如果线程正在执行的一个是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值应为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### Java虚拟机栈

和程序计数器一样，Java虚拟机栈也是线程私有的，生命周期与线程相同，虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应一个栈帧入栈出栈的过程。

在局部变量表中，存放了编译器可知的各种Java虚拟机基本数据类型、对象引用和地址。这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小(槽的数量)。

StackOverflowError异常就是线程请求的栈深度大于虚拟机所允许的深度，查看jvm线程栈大小命令如下：

```
java -XX:+PrintFlagsFinal -version | grep ThreadStackSize
java -XX:+PrintFlagsFinal -version | findstr ThreadStackSize
```

结果如下图所示：

![alt text](/assets/img/jvm/ThreadStackSize.png)

其中`{pd ergo}`表示平台默认，通常64位JVM的默认线程栈(虚拟机栈，该说法用来强调每个线程都有自己的栈)大小为1MB。

设置线程栈大小命令如下：

```
java -Xss512k MyApp
```

以下为一个出发StackOverflowError简单示例：

```java
public class StackOverflowDemo {

    // 无限递归函数
    public static void recallMethod() {
        recallMethod();
    }

    public static void main(String[] args) {
        recallMethod();
    }
}
```

OutOfMemoryError则是在无法申请到足够内存时抛出，而在HotSpot虚拟机上，Java虚拟机栈容量是不会动态扩展的，因此只要在线程申请栈空间时成功就不会出现OutOfMemoryError。

由此，我们可以知道线程栈内存大小是在JVM启动时确定的，在HotSpot虚拟机上，虚拟机栈容量不会动态扩展，那么完全可以在不同情况下设置相应的ThreadStackSize来控制线程申请的内存来减少内存消耗。

例如，线程栈大小1MB，如果创建了1000个线程，即使什么都不做，JVM也会预留 $$1000\times 1MB = 1GB$$的虚拟内存。虽然这部分不会立即占用物理内存，但是会增加进程的虚拟地址空间占用，并且可能触发OutOfMemoryError，因为上面说到线程申请内存时失败就会抛出该Error，那么在极端情况下，线程申请不到1MB的时候可能就会出现`OutOfMemoryError: unable to create new native thread`。

因此，我们可以在保证程序正常运行(不触发`StackOverflowError`)的前提下，减小每个线程栈大小，从而降低整体内存占用。相应的，对于深度递归、复杂解析的任务，也可以适当增加线程栈大小来避免触发`StackOverflowError`。

### 本地方法栈

本地方法栈与虚拟机栈发挥的作用是非常相似的，其区别只是虚拟机栈作为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。

虚拟机规范对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机(如HotSpot)直接就把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样，本地方法栈也会在栈深度溢出或栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError。

### 堆

对于Java的应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，Java中几乎所有的对象实例都在这里分配内存，在虚拟机规范中对Java堆的描述是“所有的对象实例以及数组都应当在堆上分配”，而这里的几乎，是因为会有逃逸分析，栈上分配、标量替换优化手段。

Java堆是垃圾收集器管理的内存区域，因此也称为“GC堆”，从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些区域划分仅仅是一部分垃圾收集器的共同特性或者设计风格，而并非某个Java虚拟机具体实现的固有内存布局，更不是虚拟机规范里对Java堆的进一步细分。

从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)，以提升对象分配时的效率。不过，无论从什么角度，怎么划分，都不会改变Java堆中存储内容的共性。存储的都只是对象实例。将Java堆细分只是为了更好地回收内存，或者更快地分配内存。

根据虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象(如数组)，多数虚拟机实现出于简单、存储高效的考虑，很可能要求连续的存储空间。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数-Xmx和-Xms设定)。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机会抛出OutOfMemoryError。

-Xms，设置JVM启动时的初始堆大小。-Xmx设置JVM可扩展到的最大堆大小。

显然，以上两个设置，在只设置一个设置的情况下，可能会出现，例如设置了-Xmx，但是-Xms默认值很小，那么会导致初期频繁Minor GC，扩展的时候出现Full GC。

### 方法区

方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然虚拟机规范中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是和Java堆区分。

方法区和永久代并不是等价的，因为在JDK8之前当时的HotSpot虚拟机设计选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这一部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受虚拟机规范管束。

而使用永久代来实现方法区的设计，导致了Java应用更容易遇到内存溢出的问题(永久代有-XX:MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会有问题)，而且有极少数方法(例如`String:intern()`)会因为永久代的原因导致不同虚拟机下有不同的表现。因此在JDK6的时候HotSpot就有放弃永久代，逐步改为采用本地内存(Native Memory)来实现方法区的计划。JDK7的HotSpot已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来代替，把JDK7中永久代剩下的内容全部移到元空间中。

虚拟机规范对方法区的约束非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确比较少出现，但并非数据进入了方法区就如永久代的名字一样永久存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

根据虚拟机规范规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError。

### 运行时常量池

运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中。

Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定。如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，虚拟机规范并没有任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Jaava语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入常量池中，例如`String.intern()`方法。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError。

但是在JDK7开始，HotSpot字符串对象被移到堆中，字符串常量在元空间中只存储引用，那么就避免了`String.intern()`导致的OutOfMemoryError的问题。

```java
public class StringInHeap {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = new String("hello").intern();

        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // true

        // 打印对象哈希码（基于地址）
        System.out.println("s1 hash: " + System.identityHashCode(s1));
        System.out.println("s2 hash: " + System.identityHashCode(s2));
    }
}
```

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError出现。

在JDK1.4中新加入NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据。

显然，本机直接内存的分配不会受到Java堆大小的限制，但是，肯定会受到本机总内存(物理内存、SWAP分区或分页文件)大小及处理器寻址空间的限制，直接内存也可能会出现OutOfMemoryError。

### 元空间

元空间主要包含以下内容：

1. 类的结构信息
2. 方法信息
3. 字段信息
4. 运行时常量池
5. 注解信息
6. 方法表
7. JIT编译后的代码缓存(一部分)
8. 类加载器引用
9. 内部字符串

HotSpot使用`InstanceKlass`来表示一个Java类，以下为其中字段部分：

```cpp
class InstanceKlass : public Klass {
  Symbol* _name;                // 类名，如 "java/lang/String"
  Array<Method*>* _methods;     // 方法数组
  Array<Field*>* _fields;       // 字段数组
  ConstantPool* _constants;     // 运行时常量池
  Klass* _super;                // 父类
  Annotations* _annotations;    // 类的注释
  Klass* _array_klasses;        // 包含类元素的数组类。
  // ...
};
```

如此，在一个Java类中：

```java
public class Config {
    public static final String ENV = "prod";
    public static User ADMIN = new User("admin");
}
```

其中ENV的引用和ADMIN的引用存储在元空间中，字符串对象和User实例都在Java堆中存储。元空间只存储引用，实例都在Java堆中。

### Java堆溢出

Java堆用于存储对象实例，只要我们不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生OutOfMemoryErrorr。

如下，我们先设置`-Xmx1024K -Xms1024K`，然后运行就会抛出`Exception in thread "main" java.lang.OutOfMemoryError: Java heap space`

```java
public class HeapOOM {
    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<OOMObject>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

在实际使用中，我们要区分是内存泄漏还是内存溢出，如果是内存泄漏可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径，与哪些GC Roots关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及到GC Roots引用链的信息，一般可以较准确定位到这些对象创建的位置。

如果不是内存泄漏，也就是说这些内存中的对象都是必须存活的，那就应当检查Java虚拟机的`-Xmx`和`-Xms`设置，是否能够向上调整，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

### 线程栈和本地方法栈溢出

HotSpot并不区分线程栈和本地方法栈，因此对于HotSpot来说`-Xoss`参数实际无效，栈容量只能通过`-Xss`参数设定。上面说到线程请求的栈深度大于虚拟机所运行的最大深度，将会抛出StackOverflowError。栈内存申请时失败会抛出OutOfMemoryError，如果支持动态扩展，扩展时容量无法申请也会抛出OutOfMemoryError。




## GC

Lisp是第一门开始使用内存动态分配和垃圾收集技术的语言，以下为垃圾收集需要完成的三件事情：

- 哪些对象需要回收？
- 什么时候回收？
- 如何回收？

前面介绍了Java运行时内存区域各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域生命周期与线程一致，每一个栈帧分配多少内存基本在类结构确定下来时就已知了(虽然运行时可能会由即时编译器优化，但是大体上可以认为编译期可知)，因此这几个区域的内存分配和回收都具备确定性，即不需要过多考虑如何回收。

而Java堆和方法区具有很明显的不确定性，一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有在运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存如何管理。

### 引用计数

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是并不可能再被使用的。

虽然引用计数会占用一些额外的内存空间来进行计数，但是原理简单，判定效率高。但在Java，主流的Jaav虚拟机都没有使用引用计数来管理内存，因为会有很多例外情况需要考虑，还需要大量额外的处理才能保证其能够正确地工作，例如单纯的引用计数很难解决对象之间相互循环引用的问题。

我们来创建一个循环引用的对象，然后将引用去除(即没有任何地方引用这两个实例，除了他们互相的引用)

```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    }
}
```

```
[GC (System.gc()) [PSYoungGen: 9257K->816K(150016K)] 9257K->824K(493056K), 0.0009175 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 816K->0K(150016K)] [ParOldGen: 8K->595K(343040K)] 824K->595K(493056K), [Metaspace: 3407K->3407K(1056768K)], 0.0028721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 150016K, used 6451K [0x0000000718b80000, 0x0000000723280000, 0x00000007c0000000)
  eden space 129024K, 5% used [0x0000000718b80000,0x00000007191cce68,0x0000000720980000)
  from space 20992K, 0% used [0x0000000720980000,0x0000000720980000,0x0000000721e00000)
  to   space 20992K, 0% used [0x0000000721e00000,0x0000000721e00000,0x0000000723280000)
 ParOldGen       total 343040K, used 595K [0x00000005ca200000, 0x00000005df100000, 0x0000000718b80000)
  object space 343040K, 0% used [0x00000005ca200000,0x00000005ca294cc0,0x00000005df100000)
 Metaspace       used 3421K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 365K, capacity 388K, committed 512K, reserved 1048576K
```

从上面的GC日志看，相互引用的对象被回收掉了，如此也能说明Java并未使用引用计数的方法进行垃圾回收。

### 可达性分析

基本思路通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Roots到该对象不可达，则可以证明该对象不可能再被使用。

![alt text](/assets/img/jvm/reference-chain.png)

可作为GC Roots的对象包括以下几种：

- 在虚拟机栈(栈帧中的本地变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等。
- 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用。
- 在本地方法栈中JNI引用的对象。
- Java虚拟机内部的引用，例如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器。
- 所有被同步锁(`synchronized`)持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVM TI中注册的回调，本地代码缓存等。

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”加入，构成完整的GC Roots集合。
