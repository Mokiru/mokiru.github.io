---
title: JVM虚拟机
date: 2025-08-16 10:00:00 +0800
categories: [Java]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: JVM虚拟机概述
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

## JVM运行时数据区域(内存结构)

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，

![alt text](/assets/img/jvm/运行时数据区域.png)

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型中，字节码解释器工作时，通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(如果是多核处理器就是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

如果线程正在执行的一个是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值应为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### Java虚拟机栈

和程序计数器一样，Java虚拟机栈也是线程私有的，生命周期与线程相同，虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应一个栈帧入栈出栈的过程。

在局部变量表中，存放了编译器可知的各种Java虚拟机基本数据类型、对象引用和地址。这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小(槽的数量)。

StackOverflowError异常就是线程请求的栈深度大于虚拟机所允许的深度，查看jvm线程栈大小命令如下：

```
java -XX:+PrintFlagsFinal -version | grep ThreadStackSize
java -XX:+PrintFlagsFinal -version | findstr ThreadStackSize
```

结果如下图所示：

![alt text](/assets/img/jvm/ThreadStackSize.png)

其中`{pd ergo}`表示平台默认，通常64位JVM的默认线程栈(虚拟机栈，该说法用来强调每个线程都有自己的栈)大小为1MB。

设置线程栈大小命令如下：

```
java -Xss512k MyApp
```

以下为一个出发StackOverflowError简单示例：

```java
public class StackOverflowDemo {

    // 无限递归函数
    public static void recallMethod() {
        recallMethod();
    }

    public static void main(String[] args) {
        recallMethod();
    }
}
```

OutOfMemoryError则是在无法申请到足够内存时抛出，而在HotSpot虚拟机上，Java虚拟机栈容量是不会动态扩展的，因此只要在线程申请栈空间时成功就不会出现OutOfMemoryError。

由此，我们可以知道线程栈内存大小是在JVM启动时确定的，在HotSpot虚拟机上，虚拟机栈容量不会动态扩展，那么完全可以在不同情况下设置相应的ThreadStackSize来控制线程申请的内存来减少内存消耗。

例如，线程栈大小1MB，如果创建了1000个线程，即使什么都不做，JVM也会预留 $$1000\times 1MB = 1GB$$的虚拟内存。虽然这部分不会立即占用物理内存，但是会增加进程的虚拟地址空间占用，并且可能触发OutOfMemoryError，因为上面说到线程申请内存时失败就会抛出该Error，那么在极端情况下，线程申请不到1MB的时候可能就会出现`OutOfMemoryError: unable to create new native thread`。

因此，我们可以在保证程序正常运行(不触发`StackOverflowError`)的前提下，减小每个线程栈大小，从而降低整体内存占用。相应的，对于深度递归、复杂解析的任务，也可以适当增加线程栈大小来避免触发`StackOverflowError`。

### 本地方法栈

本地方法栈与虚拟机栈发挥的作用是非常相似的，其区别只是虚拟机栈作为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。

虚拟机规范对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机(如HotSpot)直接就把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样，本地方法栈也会在栈深度溢出或栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError。

### 堆

对于Java的应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，Java中几乎所有的对象实例都在这里分配内存，在虚拟机规范中对Java堆的描述是“所有的对象实例以及数组都应当在堆上分配”，而这里的几乎，是因为会有逃逸分析，栈上分配、标量替换优化手段。

Java堆是垃圾收集器管理的内存区域，因此也称为“GC堆”，从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些区域划分仅仅是一部分垃圾收集器的共同特性或者设计风格，而并非某个Java虚拟机具体实现的固有内存布局，更不是虚拟机规范里对Java堆的进一步细分。

从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)，以提升对象分配时的效率。不过，无论从什么角度，怎么划分，都不会改变Java堆中存储内容的共性。存储的都只是对象实例。将Java堆细分只是为了更好地回收内存，或者更快地分配内存。

根据虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象(如数组)，多数虚拟机实现出于简单、存储高效的考虑，很可能要求连续的存储空间。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数-Xmx和-Xms设定)。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机会抛出OutOfMemoryError。

-Xms，设置JVM启动时的初始堆大小。-Xmx设置JVM可扩展到的最大堆大小。

显然，以上两个设置，在只设置一个设置的情况下，可能会出现，例如设置了-Xmx，但是-Xms默认值很小，那么会导致初期频繁Minor GC，扩展的时候出现Full GC。

### 方法区

方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然虚拟机规范中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是和Java堆区分。

方法区和永久代并不是等价的，因为在JDK8之前当时的HotSpot虚拟机设计选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这一部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受虚拟机规范管束。

而使用永久代来实现方法区的设计，导致了Java应用更容易遇到内存溢出的问题(永久代有-XX:MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会有问题)，而且有极少数方法(例如`String:intern()`)会因为永久代的原因导致不同虚拟机下有不同的表现。因此在JDK6的时候HotSpot就有放弃永久代，逐步改为采用本地内存(Native Memory)来实现方法区的计划。JDK7的HotSpot已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来代替，把JDK7中永久代剩下的内容全部移到元空间中。

虚拟机规范对方法区的约束非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确比较少出现，但并非数据进入了方法区就如永久代的名字一样永久存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

根据虚拟机规范规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError。

### 运行时常量池

运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中。

Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定。如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，虚拟机规范并没有任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Jaava语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入常量池中，例如`String.intern()`方法。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError。

但是在JDK7开始，HotSpot字符串对象被移到堆中，字符串常量在元空间中只存储引用，那么就避免了`String.intern()`导致的OutOfMemoryError的问题。

```java
public class StringInHeap {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = new String("hello").intern();

        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // true

        // 打印对象哈希码（基于地址）
        System.out.println("s1 hash: " + System.identityHashCode(s1));
        System.out.println("s2 hash: " + System.identityHashCode(s2));
    }
}
```

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError出现。

在JDK1.4中新加入NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据。

显然，本机直接内存的分配不会受到Java堆大小的限制，但是，肯定会受到本机总内存(物理内存、SWAP分区或分页文件)大小及处理器寻址空间的限制，直接内存也可能会出现OutOfMemoryError。

### 元空间

元空间主要包含以下内容：

1. 类的结构信息
2. 方法信息
3. 字段信息
4. 运行时常量池
5. 注解信息
6. 方法表
7. JIT编译后的代码缓存(一部分)
8. 类加载器引用
9. 内部字符串

HotSpot使用`InstanceKlass`来表示一个Java类，以下为其中字段部分：

```cpp
class InstanceKlass : public Klass {
  Symbol* _name;                // 类名，如 "java/lang/String"
  Array<Method*>* _methods;     // 方法数组
  Array<Field*>* _fields;       // 字段数组
  ConstantPool* _constants;     // 运行时常量池
  Klass* _super;                // 父类
  Annotations* _annotations;    // 类的注释
  Klass* _array_klasses;        // 包含类元素的数组类。
  // ...
};
```

如此，在一个Java类中：

```java
public class Config {
    public static final String ENV = "prod";
    public static User ADMIN = new User("admin");
}
```

其中ENV的引用和ADMIN的引用存储在元空间中，字符串对象和User实例都在Java堆中存储。元空间只存储引用，实例都在Java堆中。

### Java堆溢出

Java堆用于存储对象实例，只要我们不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生OutOfMemoryErrorr。

如下，我们先设置`-Xmx1024K -Xms1024K`，然后运行就会抛出`Exception in thread "main" java.lang.OutOfMemoryError: Java heap space`

```java
public class HeapOOM {
    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<OOMObject>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

在实际使用中，我们要区分是内存泄漏还是内存溢出，如果是内存泄漏可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径，与哪些GC Roots关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及到GC Roots引用链的信息，一般可以较准确定位到这些对象创建的位置。

如果不是内存泄漏，也就是说这些内存中的对象都是必须存活的，那就应当检查Java虚拟机的`-Xmx`和`-Xms`设置，是否能够向上调整，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

### 线程栈和本地方法栈溢出

HotSpot并不区分线程栈和本地方法栈，因此对于HotSpot来说`-Xoss`参数实际无效，栈容量只能通过`-Xss`参数设定。上面说到线程请求的栈深度大于虚拟机所运行的最大深度，将会抛出StackOverflowError。栈内存申请时失败会抛出OutOfMemoryError，如果支持动态扩展，扩展时容量无法申请也会抛出OutOfMemoryError。

使用-Xss参数减少栈内存容量：

```java
public class JavaVMStackSOF {
    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            throw e;
        }
    }
}
```

```
stack length:15317
Exception in thread "main" java.lang.StackOverflowError
...
```

定义大量本地变量，增大该方法帧中本地变量表的长度：

```java
public class JavaVMStackSOF {
    private static int stackLength = 0;

    public static void test() {
        long unused1, unused2, unused3, unused4, unused5,
                unused6, unused7, unused8, unused9, unused10,
                unused11, unused12, unused13, unused14, unused15,
                unused16, unused17, unused18, unused19, unused20,
                unused21, unused22, unused23, unused24, unused25,
                unused26, unused27, unused28, unused29, unused30,
                unused31, unused32, unused33, unused34, unused35,
                unused36, unused37, unused38, unused39, unused40,
                unused41, unused42, unused43, unused44, unused45,
                unused46, unused47, unused48, unused49, unused50,
                unused51, unused52, unused53, unused54, unused55,
                unused56, unused57, unused58, unused59, unused60,
                unused61, unused62, unused63, unused64, unused65,
                unused66, unused67, unused68, unused69, unused70,
                unused71, unused72, unused73, unused74, unused75,
                unused76, unused77, unused78, unused79, unused80,
                unused81, unused82, unused83, unused84, unused85,
                unused86, unused87, unused88, unused89, unused90,
                unused91, unused92, unused93, unused94, unused95,
                unused96, unused97, unused98, unused99, unused100;
        stackLength++;
        test();
        unused1 = unused2 = unused3 = unused4 = unused5 =
                unused6 = unused7 = unused8 = unused9 = unused10 =
                        unused11 = unused12 = unused13 = unused14 = unused15 =
                                unused16 = unused17 = unused18 = unused19 = unused20 =
                                        unused21 = unused22 = unused23 = unused24 = unused25 =
                                                unused26 = unused27 = unused28 = unused29 = unused30 =
                                                        unused31 = unused32 = unused33 = unused34 = unused35 =
                                                                unused36 = unused37 = unused38 = unused39 = unused40 =
                                                                        unused41 = unused42 = unused43 = unused44 = unused45 =
                                                                                unused46 = unused47 = unused48 = unused49 = unused50 =
                                                                                        unused51 = unused52 = unused53 = unused54 = unused55 =
                                                                                                unused56 = unused57 = unused58 = unused59 = unused60 =
                                                                                                        unused61 = unused62 = unused63 = unused64 = unused65 =
                                                                                                                unused66 = unused67 = unused68 = unused69 = unused70 =
                                                                                                                        unused71 = unused72 = unused73 = unused74 = unused75 =
                                                                                                                                unused76 = unused77 = unused78 = unused79 = unused80 =
                                                                                                                                        unused81 = unused82 = unused83 = unused84 = unused85 =
                                                                                                                                                unused86 = unused87 = unused88 = unused89 = unused90 =
                                                                                                                                                        unused91 = unused92 = unused93 = unused94 = unused95 =
                                                                                                                                                                unused96 = unused97 = unused98 = unused99 = unused100 = 0;
    }

    public static void main(String[] args) {
        try {
            test();
        } catch (Error e) {
            System.out.println("stack length:" + stackLength);
            throw e;
        }
    }
}

```


```
stack length:597
Exception in thread "main" java.lang.StackOverflowError
...
```

以上结果说明无论是由于栈帧太大还是线程栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError。

## GC

Lisp是第一门开始使用内存动态分配和垃圾收集技术的语言，以下为垃圾收集需要完成的三件事情：

- 哪些对象需要回收？
- 什么时候回收？
- 如何回收？

前面介绍了Java运行时内存区域各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域生命周期与线程一致，每一个栈帧分配多少内存基本在类结构确定下来时就已知了(虽然运行时可能会由即时编译器优化，但是大体上可以认为编译期可知)，因此这几个区域的内存分配和回收都具备确定性，即不需要过多考虑如何回收。

而Java堆和方法区具有很明显的不确定性，一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有在运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存如何管理。

### 引用计数

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是并不可能再被使用的。

虽然引用计数会占用一些额外的内存空间来进行计数，但是原理简单，判定效率高。但在Java，主流的Jaav虚拟机都没有使用引用计数来管理内存，因为会有很多例外情况需要考虑，还需要大量额外的处理才能保证其能够正确地工作，例如单纯的引用计数很难解决对象之间相互循环引用的问题。

我们来创建一个循环引用的对象，然后将引用去除(即没有任何地方引用这两个实例，除了他们互相的引用)

```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    }
}
```

```
[GC (System.gc()) [PSYoungGen: 9257K->816K(150016K)] 9257K->824K(493056K), 0.0009175 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 816K->0K(150016K)] [ParOldGen: 8K->595K(343040K)] 824K->595K(493056K), [Metaspace: 3407K->3407K(1056768K)], 0.0028721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 150016K, used 6451K [0x0000000718b80000, 0x0000000723280000, 0x00000007c0000000)
  eden space 129024K, 5% used [0x0000000718b80000,0x00000007191cce68,0x0000000720980000)
  from space 20992K, 0% used [0x0000000720980000,0x0000000720980000,0x0000000721e00000)
  to   space 20992K, 0% used [0x0000000721e00000,0x0000000721e00000,0x0000000723280000)
 ParOldGen       total 343040K, used 595K [0x00000005ca200000, 0x00000005df100000, 0x0000000718b80000)
  object space 343040K, 0% used [0x00000005ca200000,0x00000005ca294cc0,0x00000005df100000)
 Metaspace       used 3421K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 365K, capacity 388K, committed 512K, reserved 1048576K
```

从上面的GC日志看，相互引用的对象被回收掉了，如此也能说明Java并未使用引用计数的方法进行垃圾回收。

### 可达性分析

基本思路通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Roots到该对象不可达，则可以证明该对象不可能再被使用。

![alt text](/assets/img/jvm/reference-chain.png)

可作为GC Roots的对象包括以下几种：

- 在虚拟机栈(栈帧中的本地变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等。
- 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用。
- 在本地方法栈中JNI引用的对象。
- Java虚拟机内部的引用，例如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器。
- 所有被同步锁(`synchronized`)持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVM TI中注册的回调，本地代码缓存等。

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”加入，构成完整的GC Roots集合。

### 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，它建立在两个分代假说之上：

1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过多次垃圾收集过程的对象就越难以消亡

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(即熬过垃圾收集过程的次数)分配到不同的区域之中存储。显然，如果一个区域中的大多数对象都会很快消亡，那么把它们集中放在一起，每次回收时只需要关注如何保留少量存活的而不是去标记那些大量将要被回收的对象，就能以较低代价回收大量空间。同样，如果剩下的都是难以消亡的对象，把它们集中放在一块，虚拟机便能以较低的频率来回收这一个区域。

那么在Java堆划分了不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分。也才能针对不同的区域安排与之相匹配的垃圾收集算法——“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。

然而，想要分代收集并不只需要简单划分内存区域，还有一个明显的问题：对象之间跨代引用。例如，现在要进行一次只限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象带来了很大的性能负担。

跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

存在互相引用关系的两个对象，是应该倾向于同时生存或同时消亡的。例如，某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用的问题也随即被消除了。

那么，根据这条假说，我们就不需要为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需要在新生代上建立一个全局数据结构(记忆集,Remembered Set)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存存在跨代引用，后面发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots扫描。

以G1为例。`G1RemSet`是G1收集器的全局记忆集管理器。

```cpp
class G1RemSet: public CHeapObj<mtGC> {
private:
  // 每个 HeapRegion 有一个对应的 Remembered Set
  HeapRegionRemSet** _rsets;

  // 全局并发处理线程
  G1RemSetTrackingThread* _tracking_thread;

public:
  // 向某个 Region 的 RSet 中添加引用
  void add_reference(void* from, int worker_i);

  // 初始化 RSet
  void init();

  // 并发扫描 Card Table，构建 RSet
  void update_rem_set(G1ParPushHeapRSClosure* push_rem,
                      G1ParScanThreadState* pss);
};
```

每个`HeapRegion`都有一个`HeapRegionRemSet`记录谁引用了它。

```cpp
class HeapRegionRemSet: public CHeapObj<mtGC> {
private:
  // 使用 BitMap 或 SparseTable 存储引用
  union {
    BitMap* _bm;
    SparseHashtable* _st;
  } _entries;

  // RSet 类型：Sparse（稀疏）、Fine（细粒度）、Coarse（粗粒度）
  RefType _type;

public:
  // 添加一个引用（from 指向当前 Region）
  void add_reference(void* from);

  // 扫描 RSet 中的引用
  void iterate(FilteredClosure* cl);
};
```

在老年代对象修改引用时：

```cpp
void G1SATBCardTableModRefBS::enqueue(oop pre_val) {
  // Nulls should have been already filtered.
  assert(pre_val->is_oop(true), "Error");

  if (!JavaThread::satb_mark_queue_set().is_active()) return;
  Thread* thr = Thread::current();
  if (thr->is_Java_thread()) {
    JavaThread* jt = (JavaThread*)thr;
    jt->satb_mark_queue().enqueue(pre_val);
  } else {
    MutexLockerEx x(Shared_SATB_Q_lock, Mutex::_no_safepoint_check_flag);
    JavaThread::satb_mark_queue_set().shared_satb_queue()->enqueue(pre_val);
  }
}
```

### 标记-清除算法

如名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。有两个主要的缺点：第一个是执行效率不稳定，如果Java堆中包含了大量对象，而且其中大部分是需要回收的，这时必须进行大量标记和清除的动作(上面也说过，例如新生代中我们并不用关注哪些对象要消亡，而是关注较少的部分——哪些对象存活)，导致标记和清除两个过程的执行效率随着对象数量增长而降低；第二个是内存空间碎片化，标记、清除后会产生大量不连续的碎片，空间碎片太多可能导致后续程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。

### 标记-复制算法

上面说到标记-清除在面对大量对象时执行效率低的问题，标记-复制将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只需要移动堆顶指针，按顺序分配即可。实现简单，运行高效，但缺点也明显，因为将可使用内存分为两块，空间浪费太多了。

但是因为上面讲到分代收集，我们完全可以在符合存活对象少的区域使用该标记-复制算法，例如在新生代中使用标记-复制算法，并且IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集，因此我们完全可以不按照对半来划分新生代的内存空间。即如Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也即每次新生代中可用内存空间为整个新生代容量的90%，只有10%是被“浪费”的。当然，上面说到的98%对象被回收，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此还有一个安全设计，当Survivor空间不足以容纳Minor GC之后存活的对象时，就需要靠其他内存区域(大多数时候是老年代)进行分配担保。

### 标记-整理算法

标记-复制在对象存活率较高时就需要进行较多的复制操作，效率将会降低。并且不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都是100%存活的极端情况，所有在老年代一般不能直接使用这种算法。

标记-整理过程和“标记-清除”一样，但后续步骤不会直接对回收对象进行清理，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。和标记-清除本质差异在于清除是非移动式的回收算法，整理是移动式的回收算法，如果移动存活对象，那么移动存活对象并更新所有引用这些对象的地方是极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行。但如果使用标记-清除的话，虽然不需要移动，但是会产生空间碎片化的问题，只能依赖更复杂的内存分配器和内存访问器来解决。

基于以上，移动和不移动都存在弊端，移动则内存回收更复杂，不移动则内存分配更复杂。从停顿时间来看，不移动对象停顿时间更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。即使不移动对象会提升收集器效率，但是带来的内存分配和访问问题相比垃圾收集频率要大。那么这里就需要做出相应取舍，例如关注吞吐量的收集器使用标记-整理，关注延迟的收集器则可以使用标记-清除。

## 内存分配与回收策略

自动内存管理，最根本目标是自动化解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下(例如对象大小超过一定阈值)也可能会直接分配在老年代，对象分配的规则并不是固定的，虚拟机规范并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪一种垃圾收集器，以及虚拟机中与内存相关的参数的设定。

### 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

HotSpot虚拟机提供了`-XX:+PrintGCDetails`这个收集器日志参数，在发生垃圾收集行为时会打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。

以下尝试分配三个2MB大小和一个4MB大小的对象，在运行时通过设置`-Xms20M -Xmx20M -Xmn10M`三个参数限制Java堆大小为20MB，不可扩展，其中10MB分给新生代，剩下10MB分给老年代。`-XX:Survivor-Ratio=8`决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果可以看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代一共可用空间为9MB。

执行后，分配allocation4对象的语句会发生一次Minor GC，这次回收的结果是新生代6651KB变为148KB，

```java
public class TestAllocation {
    private static final int _1MB = 1024 * 1024;

    /**
     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
     */
    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB]; // 出现一次Minor GC
    }

    public static void main(String[] args) {
        testAllocation();
    }
}
```

```
Heap
 PSYoungGen      total 9216K, used 7969K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 97% used [0x00000000ff600000,0x00000000ffdc8740,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 10240K, used 4096K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff000010,0x00000000ff600000)
 Metaspace       used 3434K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 367K, capacity 388K, committed 512K, reserved 1048576K
```

