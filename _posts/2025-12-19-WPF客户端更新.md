---
title: WPF客户端更新
date: 2025-11-12 20:00:00 +0800
categories: [C#, WPF]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: 介绍使用NetSparkle进行更新校验
comments: true # 评论
pin: false # top 
math: true
---

## NetSparkle

`NetSparkle` 主要依据`xml`或`json`文件来判断当前客户端是否需要更新，以下以`xml`文件为例。一个普通的NetSparkle XML文件如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" version="2.0">
    <channel>
        <title>NetSparkle Test App</title>
        <link>https://netsparkleupdater.github.io/NetSparkle/files/sample-app/appcast.xml</link>
        <description>Most recent changes with links to updates.</description>
        <language>en</language>
        <item>
            <title>Version 2.0 (2 bugs fixed; 3 new features)</title>
            <sparkle:releaseNotesLink>
            https://netsparkleupdater.github.io/NetSparkle/files/sample-app/2.0-release-notes.md
            </sparkle:releaseNotesLink>
            <pubDate>Thu, 27 Oct 2016 10:30:00 +0000</pubDate>
            <enclosure url="https://netsparkleupdater.github.io/NetSparkle/files/sample-app/NetSparkleUpdate.exe"
                       sparkle:version="2.0"
                       sparkle:os="windows"
                       length="12288"
                       type="application/octet-stream"
                       sparkle:signature="NSG/eKz9BaTJrRDvKSwYEaOumYpPMtMYRq+vjsNlHqRGku/Ual3EoQ==" />
        </item>
    </channel>
</rss>
```

关于XML文件生成可以使用`NetSparkle`提供的工具：`dotnet tool install --global NetSparkleUpdater.Tools.AppCastGenerator`

接着我们可以使用命令`netsparkle-generate-appcast`生成。以下例子默认使用ed25519.

### 常用option

- `-a/--appcast-output-directory`：设置输出XML文件的目录，默认是执行命令的工作目录
- `-e/--ext`：发布文件扩展名，默认`exe`扩展名
- `-b/--binaries`：发布文件搜索路径目录
- `-r/--search-binary-subdirectories`：是否需要搜索子目录
- `--single-file`：直接指定单个发布文件，使用这个时，上面搜索参数就没用了
- `-f/--file-extract-version`：是否从文件名中提取版本号，默认false，直接从文件提取
- `--file-version`：设置文件版本号，但是一般都不设置
- `-o/--os`：使用WPF时基本不使用，因为默认Windows
- `-description-tag`：设置XML文件中`<channel>`中的`<description>`
- `--link-tag`：设置XML文件中`<channel>`中的`<link>`
- `-u/--base-url`：即base url，后面初始化发布文件下载路径时会默认将baseurl和文件名拼接
- `-l/--change-log-url`：变更日志的base url
- `-p/--change-log-path`：变更日志文件路径Markdown格式，扩展名`md`，并且文件名必须包含版本号
- `--change-log-name-prefix`：变更日志文件名前缀，默认搜索`[版本号].md`，使用过后还会搜索`[prefix][版本号].md`
- `-n/--product-name`：产品名称，即`<channel>`中`<title>`
- `-x/--url-prefix-version`：下载链接的文件名前添加版本号，如`App-1.2.0.0.exe`最后的下载路径为`[base url]/1.2.0.0/App.exe`
- `--key-path`：指定公私钥所在文件夹
- `--signature-file-extension`：设置appcast签名文件后缀名，默认后缀名`signature`即`appcast.xml.signature`
- `--output-file-name`：appcast文件的输出名称
- `--use-ed25519-signature-attribute`：若appcast输出格式是XML且当前true，则将签名属性`signature`设置为`edSignature`
- `--critical-versions`：逗号分隔关键版本列表，仅标记作用
- `--reparse-existing`：重新解析发布，不覆盖当前已经生成的appcast文件，跳过appcast文件中版本号与当前发布相同的项，如果需要新增将会追加
- `--human-readable`：appcast缩进，可读
- `--output-type`：设置appcast文件为xml或json
- `--public-key-override`：使用指定的公钥
- `--private-key-override`：使用指定的私钥
- `--generate-keys`：初始化公钥私钥
- `--force`：一般不使用，因为该操作会覆盖现有的密钥，但是一般不选择覆盖而是新增或者复用
- `--export`：将密钥输出控制台，一般结合`--generate-keys`使用
- `--generate-signature`：将发布文件签名输出控制台
- `--verify`：仅验证ed25519，指定文件路径
- `--signature`：该文件的base64签名与`--verify`一起使用

### 生成ed25519密钥

我们可以固定每次生成XML文件的密钥，这样客户端的公钥是固定的。

`netsparkle-generate-appcast --generate-keys`该命令会生成一个`NetSparkle_Ed25519.pub`文件和一个`NetSparkle_Ed25519.priv`文件分别是公钥和密钥，将这两个文件放在一个文件夹中。

### 生成XML

`netsparkle-generate-appcast --output-type xml --key-path [密钥所在目录] --base-url [下载文件路径base url] --use-ed25519-signature-attribute`

### 校验与下载

```csharp
SparkleUpdater _updater = new SparkleUpdater(xml_path, new Ed25519Checker(SecurityMode.OnlyVerifySoftwareDownloads, file_pub_key));
UpdateInfo info = await _updater.CheckForUpdatesQuietly()
```

获取到的`UpdateInfo`有许多状态，一般认为`info.Status == UpdateStatus.UpdateAvailable`说明有更新，接着需要进行下载：

```csharp
AppCastItem item = info.Updates.First(); // 这里根据自己情况选择正确的item
_updater.InitAndBeginDownload(item);
```

### 下载事件

事件名称都很好理解，分别是`DownloadStarted`、`DownloadMadeProgress`、`DownloadFinished`、`DownloadHadError`，常用的就这些事件，其中`DownloadMadeProgress`主要是获取下载进度的。


## 自定义

虽然官方推荐实现`IAppCastGenerater`接口来自定义序列化和反序列化，但是一般用XML文件就够了，只需要修改`netsprakle-generate-appcast`这个入口函数即可：

```csharp
using System;
using System.IO;
using System.Collections.Generic;
using CommandLine;
using System.Linq;
using Console = Colorful.Console;
using System.Drawing;
using NetSparkleUpdater.AppCastGenerator;

namespace NetSparkleUpdater.Tools.AppCastGenerator
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // By default, if no args given, print help
            if (args.Length == 0)
            {
                args = ["--help"];
            }
            Parser.Default.ParseArguments<Options>(args)
                .WithParsed(Run)
                .WithNotParsed(HandleParseError);
        }
        static void Run(Options opts)
        {

            if (opts.ShowExtendedExamples)
            {
                PrintExtendedExamples();
                return;
            }

            var signatureManager = new SignatureManager();

            if (!string.IsNullOrWhiteSpace(opts.PathToKeyFiles))
            {
                signatureManager.SetStorageDirectory(opts.PathToKeyFiles);
            }

            if (opts.ExportKeys)
            {
                if (!signatureManager.KeysExist())
                {
                    Console.WriteLine("Error: You must first generate keys before trying to export them!", Color.Red);
                    return;
                }
                var privateKey = signatureManager.GetPrivateKey();
                var publicKey = signatureManager.GetPublicKey();
                if (privateKey == null)
                {
                    Console.WriteLine("Error: Could not load private key!", Color.Red);
                }
                if (publicKey == null)
                {
                    Console.WriteLine("Error: Could not load public key!", Color.Red);
                }
                Console.WriteLine("Private Key:");
                Console.WriteLine(Convert.ToBase64String(privateKey ?? []));
                Console.WriteLine("Public Key:");
                Console.WriteLine(Convert.ToBase64String(publicKey ?? []));
                return;
            }

            if (opts.GenerateKeys)
            {
                var didSucceed = signatureManager.Generate(opts.ForceRegeneration);
                if (didSucceed)
                {
                    Console.WriteLine("Keys successfully generated", Color.Green);
                }
                else
                {
                    Console.WriteLine("Keys failed to generate", Color.Red);
                }
                return;
            }

            if (!string.IsNullOrWhiteSpace(opts.PublicKeyOverride))
            {
                signatureManager.SetPublicKeyOverride(opts.PublicKeyOverride);
            }
            if (!string.IsNullOrWhiteSpace(opts.PrivateKeyOverride))
            {
                signatureManager.SetPrivateKeyOverride(opts.PrivateKeyOverride);
            }

            if (opts.BinaryToSign != null)
            {
                var signature = signatureManager.GetSignatureForFile(new FileInfo(opts.BinaryToSign));

                Console.WriteLine($"Signature: {signature}", Color.Green);

                return;
            }

            if (opts.BinaryToVerify != null)
            {
                var result = signatureManager.VerifySignature(new FileInfo(opts.BinaryToVerify), opts.Signature ?? "");

                if (result)
                {
                    Console.WriteLine($"Signature valid", Color.Green);
                } 
                else
                {
                    Console.WriteLine($"Signature invalid", Color.Red);
                }

                return;
            }

            // actually create the app cast
            AppCastMaker generator = opts.OutputType?.ToLower() != "json"
                ? new XMLAppCastMaker(signatureManager, opts)
                : new JsonAppCastMaker(signatureManager, opts);
            var appCastFileName = generator.GetPathToAppCastOutput(
                opts.OutputDirectory ?? ".", 
                opts.SourceBinaryDirectory ?? ".", 
                opts.OutputFileName ?? "appcast"
            );
            var outputDirName = Path.GetDirectoryName(appCastFileName);
            if (outputDirName == null || string.IsNullOrWhiteSpace(outputDirName))
            {
                Console.WriteLine("Output directory name is null/whitespace", Color.Red);
                return;
            }
            if (!Directory.Exists(outputDirName))
            {
                Console.WriteLine("Creating {0}", outputDirName);
                Directory.CreateDirectory(outputDirName);
            }
            var (items, productName) = generator.LoadAppCastItemsAndProductName(opts.SourceBinaryDirectory ?? ".", opts.ReparseExistingAppCast, appCastFileName, opts.FileToAddToAppCast ?? "");
            if (items != null)
            {
                generator.SerializeItemsToFile(items, productName ?? "", appCastFileName);
                generator.CreateSignatureFile(appCastFileName, opts.SignatureFileExtension ?? "");
            }
        }

        static void HandleParseError(IEnumerable<Error> errs)
        {
            errs.Output();
        }

        static void PrintExtendedExamples()
        {
            var examples = @"
#### Key Generation
# Generate Ed25519 keys for the first time
netsparkle-generate-appcast --generate-keys
# Store keys in a custom location (use the same --key-path param when creating an app cast if storing in a custom location!)
netsparkle-generate-appcast --generate-keys --key-path path/to/store/keys
# Pass in public key via command line
netsparkle-generate-appcast --public-key-override [YourPublicKeyHere]
# Pass in private key via command line
netsparkle-generate-appcast --private-key-override [YourPrivateKeyHere]

# By default, your Ed25519 signatures are stored on disk in your local 
# application data folder in a subdirectory called `netsparkle`. 
# If you want to export your keys to the console, you can do:
netsparkle-generate-appcast --export

# You can also store your keys in the following environment variables:
# set public key: SPARKLE_PUBLIC_KEY
# set private key: SPARKLE_PRIVATE_KEY

#### Generate a signature for a binary without creating an app cast:
netsparkle-generate-appcast --generate-signature path/to/binary.exe

#### Verifying Binaries
netsparkle-generate-appcast --verify path/to/binary.exe --signature base_64_signature

#### Using a custom key location:
# If your keys are sitting on disk somewhere
# (`NetSparkle_Ed25519.priv` and `NetSparkle_Ed25519.pub` -- both 
# in base 64 and both on disk in the same folder!), you can pass in 
# the path to these keys like this:
netsparkle-generate-appcast --key-path path/to/keys/

#### Generating an app cast

# Generate an app cast for Windows executables that are sitting in a 
# specific directory
netsparkle-generate-appcast -a directory/for/appcast/output/ -e exe -b directory/with/binaries/ -o windows

# Add change log info to your app cast
netsparkle-generate-appcast -b binary/folder -p change/log/folder

# Customize download URL for binaries and change logs
netsparkle-generate-appcast -b binary/folder -p change/log/folder -u https://example.com/downloads -p https://example.com/downloads/changelogs

# Set your application name for the app cast
netsparkle-generate-appcast -n ""My Awesome App"" -b binary/folder

# Use file versions in file names, e.g. for apps like ""My App 1.2.1.dmg""
netsparkle-generate-appcast -n ""macOS version"" -o macos -f true -b binary_folder -e dmg

# Don't overwrite the entire app cast file
netsparkle-generate-appcast --reparse-existing

# Don't overwrite the entire app cast file, but do overwrite items that are still on disk
netsparkle-generate-appcast --reparse-existing --overwrite-old-items

# Don't overwrite the entire app cast file and manually set the file version for one binary (if multiple binaries are found without corresponding version numbers, this will result in an error; you can use --file-extract-version instead and make sure your file/folder names contain version numbers)
netsparkle-generate-appcast --reparse-existing --file-version 1.2.1

";
            Console.Write(examples);
        }
    }
}
```

我们只需要初始化一下`Options`即可，填写一些必要参数，当然这些参数可以和最后XML生成结果对照一下，然后`<channel>`中的`<item>`对应着`AppCastItem`类，即上面`Run`方法最后的`var (items, productName) = generator.LoadAppCastItemsAndProductName(opts.SourceBinaryDirectory ?? ".", opts.ReparseExistingAppCast, appCastFileName, opts.`，因此我们想要修改`<item>`内容可以在这里修改。