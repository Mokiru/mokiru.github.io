---
title: JOOQ
date: 2025-03-18 20:00:00 +0800
categories: [Database, Java]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: Something about jooq
comments: true # 评论
pin: true # top 
math: true
---

## 简介

JOOQ是一个ORM(对象关系映射)框架，自动生成Java代码和API，快速构建有类型约束的安全的SQL语句。核心在于将数据库表结构映射为Java类，包含表的基本描述和所有表字段。通过JOOQ提供的API，配合生成的Java代码，可以方便的进行数据库操作。

生成的Java代码字段类型是根据数据库映射成的Java类型，在进行设置和查询操作时，因为是Java代码，都会有强类型校验，所以对于数据的输入，是天然安全的，极大的减少了SQL注入的风险。

JOOQ的代码生成策略是根据配置全量生成，任何对于数据库的改动，如果会影响到业务代码，在编译期间就会被发现，可以及时进行修复。

### 一般流程

1. 创建/更新数据表
2. 通过JOOQ插件生成Java代码
3. 进行业务逻辑开发

maven配置：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>${mysql.version}</version>
</dependency>
<!-- base jooq dependency -->
<dependency>
    <groupId>org.jooq</groupId>
    <artifactId>jooq</artifactId>
    <version>${jooq.version}</version>
</dependency>
```

代码生成：
1. 使用maven插件进行生成，填完信息过后使用插件中的`jooq-codegen:generate`生成即可：
    ```xml
    <plugin>
        <groupId>org.jooq</groupId>
        <artifactId>jooq-codegen-maven</artifactId>
        <version>${jooq.version}</version>
        <configuration>
            <!-- Configure the database connection here -->
            <jdbc>
              <driver>oracle.jdbc.OracleDriver</driver>
              <url>jdbc:oracle:thin:@[your jdbc connection parameters]</url>
              <user>[your database user]</user>
              <password>[your database password]</password>

              <!-- You can also pass user/password and other JDBC properties in   the   optional properties tag: -->
              <properties>
                <property><key>user</key><value>[db-user]</value></property>
                <property><key>password</key><value>[db-password]</value></   property>
              </properties>
            </jdbc>

            <generator>
              <database>
                <!-- The database dialect from jooq-meta. Available dialects are
                     named org.jooq.meta.[database].[database]Database.

                     Natively supported values are:

                         org.jooq.meta.ase.ASEDatabase
                         org.jooq.meta.auroramysql.AuroraMySQLDatabase
                         org.jooq.meta.aurorapostgres.AuroraPostgresDatabase
                         org.jooq.meta.clickhouse.ClickHouseDatabase
                         org.jooq.meta.cockroachdb.CockroachDBDatabase
                         org.jooq.meta.databricks.DatabricksDatabase
                         org.jooq.meta.db2.DB2Database
                         org.jooq.meta.derby.DerbyDatabase
                         org.jooq.meta.firebird.FirebirdDatabase
                         org.jooq.meta.h2.H2Database
                         org.jooq.meta.hana.HANADatabase
                         org.jooq.meta.hsqldb.HSQLDBDatabase
                         org.jooq.meta.ignite.IgniteDatabase
                         org.jooq.meta.informix.InformixDatabase
                         org.jooq.meta.ingres.IngresDatabase
                         org.jooq.meta.mariadb.MariaDBDatabase
                         org.jooq.meta.mysql.MySQLDatabase
                         org.jooq.meta.oracle.OracleDatabase
                         org.jooq.meta.postgres.PostgresDatabase
                         org.jooq.meta.redshift.RedshiftDatabase
                         org.jooq.meta.snowflake.SnowflakeDatabase
                         org.jooq.meta.sqldatawarehouse.SQLDataWarehouseDatabase
                         org.jooq.meta.sqlite.SQLiteDatabase
                         org.jooq.meta.sqlserver.SQLServerDatabase
                         org.jooq.meta.sybase.SybaseDatabase
                         org.jooq.meta.teradata.TeradataDatabase
                         org.jooq.meta.trino.TrinoDatabase
                         org.jooq.meta.vertica.VerticaDatabase

                     This value can be used to reverse-engineer generic JDBC      DatabaseMetaData (e.g. for MS Access)

                         org.jooq.meta.jdbc.JDBCDatabase

                     This value can be used to reverse-engineer standard  jOOQ-meta    XML formats

                         org.jooq.meta.xml.XMLDatabase

                     This value can be used to reverse-engineer schemas defined   by    SQL files
                     (requires jooq-meta-extensions dependency)

                         org.jooq.meta.extensions.ddl.DDLDatabase

                     This value can be used to reverse-engineer schemas defined   by    JPA annotated entities
                     (requires jooq-meta-extensions-hibernate dependency)

                         org.jooq.meta.extensions.jpa.JPADatabase

                     This value can be used to reverse-engineer schemas defined   by    Liquibase migration files
                     (requires jooq-meta-extensions-liquibase dependency)

                         org.jooq.meta.extensions.liquibase.LiquibaseDatabase

                     You can also provide your own org.jooq.meta.Database         implementation
                     here, if your database is currently not supported -->
                <name>org.jooq.meta.oracle.OracleDatabase</name>

                <!-- All elements that are generated from your schema (A Java     regular     expression.
                     Use the pipe to separate several expressions) Watch out for
                     case-sensitivity. Depending on your database, this might be
                     important!

                     You can create case-insensitive regular expressions using    this   syntax: (?i:expr)

                     Whitespace is ignored and comments are possible.
                     -->
                <includes>.*</includes>

                <!-- All elements that are excluded from your schema (A Java  regular  expression.
                     Use the pipe to separate several expressions). Excludes  match    before
                     includes, i.e. excludes have a higher priority -->
                <excludes>
                     UNUSED_TABLE                # This table (unqualified name)      should not be generated
                   | PREFIX_.*                   # Objects with a given prefix    should     not be generated
                   | SECRET_SCHEMA\.SECRET_TABLE # This table (qualified name)    should     not be generated
                   | SECRET_ROUTINE              # This routine (unqualified  name) ...
                </excludes>

                <!-- The schema that is used locally as a source for meta     information.
                     This could be your development schema or the production  schema,  etc
                     This cannot be combined with the schemata element.

                     If left empty, jOOQ will generate all available schemata.    See the
                     manual's next section to learn how to generate several   schemata  -->
                <inputSchema>[your database schema / owner / name]</inputSchema>
              </database>
              <!-- Generation flags: See advanced configuration properties -->
              <generate/>
                <target>
                    <!-- The destination package of your generated classes (within the
                         destination directory)

                         jOOQ may append the schema name to this package if   generating    multiple schemas,
                         e.g. org.jooq.your.packagename.schema1
                              org.jooq.your.packagename.schema2 -->
                    <packageName>org.jooq.your.packagename</packageName>

                    <!-- The destination directory of your generated classes -->
                    <directory>/path/to/your/dir</directory>
                </target>
            </generator>
        </configuration>
    </plugin>
    ```
    
2. 我们也可以使用代码的方式生成，需要导入依赖`jooq-codegen`：
    ```java
    public static void main(String[] args) throws Exception {
        Configuration configuration = new Configuration()
                .withJdbc(new Jdbc()
                        .withDriver("com.mysql.cj.jdbc.Driver")
                        .withUrl("jdbc:mysql://127.0.0.1:3306/cmdb?serverTimezone=GMT%2B8")
                        .withUser("root")
                        .withPassword("hoshino"))
                .withGenerator(new Generator()
                        .withDatabase(new Database()
                                .withIncludes(".*")
                                .withExcludes("")
                                .withInputSchema("cmdb"))
                        .withTarget(new Target()
                                .withPackageName("com.example.jooqdemo.jooq")
                                .withDirectory("src/main/java")));

        GenerationTool.generate(configuration);
    }
    ```
3. 其实上面这种办法和maven插件读取xml一样，自然我们可以使用代码来加载xml进行初始化：
    ```java
    Configuration configuration = JAXB.unmarshal(new File("jooq.xml"), Configuration.class);
    configuration.getJdbc()
                .withUser("username")
                .withPassword("password");

    GenerationTool.generate(configuration);
    ```

### 使用

从最简单的使用开始，如下：

```java
public static void main(String[] args) {
    try (Connection connection = DriverManager.getConnection(url, username, password)) {
        DSLContext context = DSL.using(connection);
        Result<Record> recordResult = context.select().from(User.USER).fetch();
        recordResult.forEach(record -> {
            Long id = record.getValue(User.USER.ID);
            System.out.println(id);
        });
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```

那么我们可以知道执行SQL的关键在于使用`DSLContext`，而该对象又是通过`DSL.using(...)`方法创建的，那么我们来看看该方法：

```java
public class DSL {
    public static DSLContext using(SQLDialect dialect) {
        return new DefaultDSLContext(dialect, (Settings)null);
    }

    public static DSLContext using(SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(dialect, settings);
    }

    public static DSLContext using(String url) {
        try {
            Connection connection = DriverManager.getConnection(url);
            return using((ConnectionProvider)(new DefaultConnectionProvider(connection, true)), (SQLDialect)JDBCUtils.dialect(connection));
        } catch (SQLException var2) {
            throw Tools.translate("Error when initialising Connection", var2);
        }
    }

    public static DSLContext using(String url, String username, String password) {
        try {
            Connection connection = DriverManager.getConnection(url, username, password);
            return using((ConnectionProvider)(new DefaultConnectionProvider(connection, true)), (SQLDialect)JDBCUtils.dialect(connection));
        } catch (SQLException var4) {
            throw Tools.translate("Error when initialising Connection", var4);
        }
    }

    public static DSLContext using(String url, Properties properties) {
        try {
            Connection connection = DriverManager.getConnection(url, properties);
            return using((ConnectionProvider)(new DefaultConnectionProvider(connection, true)), (SQLDialect)JDBCUtils.dialect(connection));
        } catch (SQLException var3) {
            throw Tools.translate("Error when initialising Connection", var3);
        }
    }

    public static DSLContext using(Connection connection) {
        return new DefaultDSLContext(connection, JDBCUtils.dialect(connection), (Settings)null);
    }

    public static DSLContext using(Connection connection, SQLDialect dialect) {
        return new DefaultDSLContext(connection, dialect, (Settings)null);
    }

    public static DSLContext using(Connection connection, Settings settings) {
        return new DefaultDSLContext(connection, JDBCUtils.dialect(connection), settings);
    }

    public static DSLContext using(Connection connection, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connection, dialect, settings);
    }

    public static DSLContext using(DataSource datasource, SQLDialect dialect) {
        return new DefaultDSLContext(datasource, dialect);
    }

    public static DSLContext using(DataSource datasource, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(datasource, dialect, settings);
    }

    public static DSLContext using(ConnectionProvider connectionProvider, SQLDialect dialect) {
        return new DefaultDSLContext(connectionProvider, dialect);
    }

    public static DSLContext using(ConnectionProvider connectionProvider, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connectionProvider, dialect, settings);
    }

    public static DSLContext using(Configuration configuration) {
        return new DefaultDSLContext(configuration);
    }
}
```

其中使用`Connection`初始化时，`JDBCUtils.dialect`会解析URL判断所使用的数据库，并且使用`Connection`的元数据判断版本等操作，当然也可以不传入创建好的`Connection`，可以交由JOOQ来创建，只需要传入一些信息即可，那么我们具体看看JOOQ是如何创建连接的，从上面可以看见使用了`Connection connection = DriverManager.getConnection(url, properties);`一个常见的方法，获取一个连接，然后创建了一个`DefaultConnectionProvider`对象：

```java
public class DefaultConnectionProvider implements ConnectionProvider {
    private static final JooqLogger log = JooqLogger.getLogger(DefaultConnectionProvider.class);
    Connection connection;
    final boolean finalize;

        public DefaultConnectionProvider(Connection connection) {
        this(connection, false);
    }

    DefaultConnectionProvider(Connection connection, boolean finalize) {
        this.connection = connection;
        this.finalize = finalize;
    }

    public final Connection acquire() {
        return this.connection;
    }

    public final void release(Connection released) {
    }

    protected void finalize() throws Throwable {
        if (this.finalize) {
            JDBCUtils.safeClose(this.connection);
        }

        super.finalize();
    }
    ...
}
```

可以看到就是一个简单的连接提供，单纯的保存了创建的连接。不过这个方法可以保证这个连接是由JOOQ独有的，而传入连接的方式并不能保证，因为`Connection`是在外部创建的，当然可以人为的保证连接由JOOQ单独使用也是没有问题的，并且需要保证这个连接不在其他地方使用，因为JOOQ会管理连接生命周期，事务等，在其他地方使用可能会导致事务混乱的问题，如果连接来自连接池，有的连接池回收情况会在长时间占用时回收连接，那么JOOQ这种情况就很容易突然失去连接抛出异常等。

因此，在无法确保独占性时，尽量使用`Configuration`的方式，那么我们来看看JOOQ的`Configuration`是什么：

```java
public interface Configuration extends Serializable {
    DSLContext dsl();

    Map<Object, Object> data();

    Object data(Object var1);

    Object data(Object var1, Object var2);

    Clock clock();

    ConnectionProvider connectionProvider();

    MetaProvider metaProvider();

    ExecutorProvider executorProvider();

    TransactionProvider transactionProvider();

    TransactionListenerProvider[] transactionListenerProviders();

    DiagnosticsListenerProvider[] diagnosticsListenerProviders();

    UnwrapperProvider unwrapperProvider();

    RecordMapperProvider recordMapperProvider();

    RecordUnmapperProvider recordUnmapperProvider();

    RecordListenerProvider[] recordListenerProviders();

    ExecuteListenerProvider[] executeListenerProviders();

    VisitListenerProvider[] visitListenerProviders();

    /** @deprecated */
    @Deprecated
    ConverterProvider converterProvider();

    /** @deprecated */
    @Deprecated
    SchemaMapping schemaMapping();

    SQLDialect dialect();

    SQLDialect family();

    Settings settings();

    Configuration set(Clock var1);

    Configuration set(ConnectionProvider var1);

    Configuration set(MetaProvider var1);

    Configuration set(ExecutorProvider var1);

    Configuration set(Executor var1);

    Configuration set(Connection var1);

    Configuration set(DataSource var1);

    Configuration set(TransactionProvider var1);

    Configuration set(RecordMapper<?, ?> var1);

    Configuration set(RecordMapperProvider var1);

    Configuration set(RecordUnmapper<?, ?> var1);

    Configuration set(RecordUnmapperProvider var1);

    Configuration set(RecordListener... var1);

    Configuration set(RecordListenerProvider... var1);

    Configuration set(ExecuteListener... var1);

    Configuration set(ExecuteListenerProvider... var1);

    Configuration set(VisitListener... var1);

    Configuration set(VisitListenerProvider... var1);

    Configuration set(TransactionListener... var1);

    Configuration set(TransactionListenerProvider... var1);

    Configuration set(DiagnosticsListener... var1);

    Configuration set(DiagnosticsListenerProvider... var1);

    Configuration set(Unwrapper var1);

    Configuration set(UnwrapperProvider var1);

    /** @deprecated */
    @Deprecated
    Configuration set(ConverterProvider var1);

    Configuration set(SQLDialect var1);

    Configuration set(Settings var1);

    Configuration derive();

    Configuration derive(Clock var1);

    Configuration derive(Connection var1);

    Configuration derive(DataSource var1);

    Configuration derive(ConnectionProvider var1);

    Configuration derive(MetaProvider var1);

    Configuration derive(Executor var1);

    Configuration derive(ExecutorProvider var1);

    Configuration derive(TransactionProvider var1);

    Configuration derive(RecordMapper<?, ?> var1);

    Configuration derive(RecordMapperProvider var1);

    Configuration derive(RecordUnmapper<?, ?> var1);

    Configuration derive(RecordUnmapperProvider var1);

    Configuration derive(RecordListener... var1);

    Configuration derive(RecordListenerProvider... var1);

    Configuration derive(ExecuteListener... var1);

    Configuration derive(ExecuteListenerProvider... var1);

    Configuration derive(VisitListener... var1);

    Configuration derive(VisitListenerProvider... var1);

    Configuration derive(TransactionListener... var1);

    Configuration derive(TransactionListenerProvider... var1);

    Configuration derive(DiagnosticsListener... var1);

    Configuration derive(DiagnosticsListenerProvider... var1);

    Configuration derive(Unwrapper var1);

    Configuration derive(UnwrapperProvider var1);

    /** @deprecated */
    @Deprecated
    Configuration derive(ConverterProvider var1);

    Configuration derive(SQLDialect var1);

    Configuration derive(Settings var1);
}
```






