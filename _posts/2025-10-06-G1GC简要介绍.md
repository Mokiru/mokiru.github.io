---
title: JVM G1GC介绍
date: 2025-10-06 20:00:00 +0800
categories: [Java, GC]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: 介绍JVM的G1GC
comments: true # 评论
pin: false # top 
math: true
---

## 并行GC和并发GC

G1GC算法组合使用了并行GC(parallel GC)和并发GC(concurrent GC)，一般来说，以多线程执行的GC就被称为并行GC/并发GC，虽然“并行”“并发”两个词相似，但是在GC中完全不同。

并行GC会先暂停mutator的运行，然后开启多个线程并行执行GC。并发GC是在不暂停mutator运行的同时，直接开启GC线程，并发执行GC。总的来说，并行GC目标是尽量缩短暂停mutator的暂停时间，并发GC目的是消除mutator的暂停时间。

显然，并发GC标记存活对象的过程中，由于mutator是不暂停的，那么对象的引用关系可能会被mutator改变。GC线程需要知道这些引用变化。

## G1GC

### G1GC软实时性

G1GC具有软实时性，具备以下两个功能：

1. 设置期望暂停时间(最后期限)
2. 可预测性

可预测性指预测下次GC会导致mutator暂停多长时间的功能。根据预测出来的结果，G1GC会通过延迟执行GC、拆分GC目标对象等手段来遵守1中的期望暂停时间，通过这种方式，能够尽量减少超出期望暂停时间的频率，实现软实时性。

### 堆结构

堆的内部被划分为大小相等的区域(region)，所有区域排成一排。G1GC以区域为单位进行GC。用户可以随意设置区域大小，但是内部会将用户设置的值向上调整为2的指数幂($$2^n$$)，并以该正数作为区域的大小。

如果正在分配对象的某个区域已经满了，GC线程会寻找下一个空闲的区域来进行分配，空闲区域是通过链表进行管理的，因此查找的时间复杂度是固定的O(1)。

![alt text](/assets/img/G1GC/堆结构.png)

### 执行过程

G1GC主要有下面两个功能：

1. 并发标记
2. 转移

并发标记基本能和mutator并发执行，会针对区域内所有的存活对象进行标记；转移负责释放堆中死亡对象所占用的内存空间。

首先，从众多区域中选择一个进行GC操作，如果该区域中有存活对象，则将其复制到其他空闲区域中：

![alt text](/assets/img/G1GC/堆的状态.png)

当选择的空闲区域也满了的时候，GC线程会再次选择其他空闲区域来存放对象。对象复制完成之后，只剩下死亡对象的区域会被重置为空闲区域以便复用。

### 并发标记和转移

并发标记是由并发标记线程来执行，并发标记的作用是在尽量不暂停mutatot的情况下标记存活对象，而且，还需要在并发标记结束之后记录下每个区域内存活对象的数量。

转移的作用是将待回收区域内的存活对象复制到其他的空闲区域，然后将待回收区域重置为空闲状态，

并发标记和转移在处理上是相互独立的，并发标记的结果信息对于转移来说并不是必须的，因此，转移处理可能发生在并发标记开始之前，也可能发生在并发标记的过程中。

## 并发标记

在简单标记中，所有可从根直接触达的对象都会被添加标记。带标记的是存活对象，不带标记的是死亡对象。

![alt text](/assets/img/G1GC/标记开始时和结束时的堆的状态.png)

上图表示标记开始时和结束时的堆的状态。标记结束后，可从根触达的对象a、b、c都带有标记，而对象d、e则会因为不带标记而被当作死亡对象处理。

### 标记位图

![alt text](/assets/img/G1GC/标记位图和区域的内部结构.png)

上图表示堆中的一个区域。位图中的黑色表示已标记，白色表示未标记。带有叉号的是死亡对象。每个区域都带有两个标记位图：`next`和`prev`。`next`是本次标记的标记位图，而`prev`是上次标记的标记位图，保存了上次标记的结果。

标记位图中每个比特都对应着关联区域内的对象的开头部分。我们假设单个对象的大小都是8个字节，那么每8个字节就会对应标记位图中的1个比特。上图标记位图里黑色的地方表示比特值是1，白色的地方表示的比特值是0。相应地，区域内黑色的是存活对象，带有叉号的是死亡对象。

`bottom`表示区域内众多对象的末尾，`top`表示开头。`nextTAMS`中的`TAMS`是“Top At Marking Start”(标记开始时的`top`)的缩写。`nextTAMS`保存了本次标记开始时的`top`，而`prevTAMS`保存了上次标记开始时的`top`。

### 执行步骤

并发标记过程包括以下5个步骤：

1. 初始标记阶段
2. 并发标记阶段
3. 最终标记阶段
4. 存活对象计数
5. 收尾工作

初始标记阶段中，暂停mutator的运行，标记可由根直接引用的对象；并发标记阶段中标记1中标记的对象所引用的对象。该步骤会开启并发标记线程进行标记，这个过程和mutator的运行是并发执行的；最终标记阶段中会扫描2中没有标记的对象，在该步骤结束后，堆内所有存活的对象都会被标记。存活对象计数对每个区域中被标记的对象进行计数，这个过程和mutator并发执行的；收尾工作主要进行一些收尾工作，并为下次标记做准备，该步骤结束之后，整个并发标记过程全部结束。

其中2、3、4、5四个步骤一般都会开启多个线程，并行地执行任务。

### 初始标记阶段

![alt text](/assets/img/G1GC/初始标记阶段结束后区域的状态.png)

在初始标记阶段，GC线程会首先创建标记位图`next`。`nextTAMS`指的就是标记开始时`top`所在的位置，所以在这里我们将它和`top`对齐。在创建位图时，其大小也和`top`对其，为“(top-bottom)/8”字节。这些处理都是和mutator并发进行的。

对可由根直接引用的对象进行标记的过程叫做**根扫描**。等所有区域的标记位图都创建完成之后，就可以开始进行根扫描了。

为了防止在根扫描的过程中根被修改，在这个过程中mutator是暂停执行的，虽然G1GC中采用写屏障技术可以获知对象的修改，但是大多数根并不是对象，它们的修改并不能被写屏障获知，因此在进行根扫描时必须暂停mutator的执行。

根需要频繁修改，所以其中大部分不在写屏障可以获知的范围内，也许G1GC的设计者认为，与其频繁地通过写屏障去获知修改地方式，还不如直接暂停mutator来进行根扫描地方式性能更佳。

如果一个对象本身被标记了，但其子对象并没有被扫描，我们就称它为**未扫描对象**。上图使用灰色表示未扫描对象。虽然图中该对象已在根扫描中被标记，但其子对象还没有被扫描到，所以是未扫描对象。也就是说，对象C持有子对象A和E，但是因为根扫描不会扫描子对象，所以对象C作为未扫描对象被表示为灰色。

完成根扫描后，mutator会再次开启执行，GC处理也会进入下一阶段。

### 并发标记阶段

在并发标记阶段，GC线程继续扫描在初始标记阶段被标记过地对象，完成对大部分存活对象的标记。

![alt text](/assets/img/G1GC/并发标记阶段结束后区域的状态.png)

上图表示的是并发标记阶段结束后区域的状态，对象C的子对象A和E都被标记了。像E这样，一个对象对应了标记位图中多个位的情况，只有起始的标记位(mark bit)会被涂成黑色。

并发标记阶段的一个重要特点是GC线程和mutator是并发执行的。因为mutator在执行过程中可能会改变对象之间的引用关系，所以如果只采用一般的标记方法，可能会发生“标记遗漏”。因此，必须使用写屏障技术来记录对象间引用关系的变化。并发标记阶段也会标记和扫描被写屏障获知变化的对象。

处理完待标记对象之后，就会进入最终标记阶段。

#### SATB

SATB(Snapshot At The Beginning，初始快照)是一种将并发标记阶段开始时对象间的引用关系，以逻辑快照的形式进行保存的手段。在SATB中，标记过程中新生成的对象会被看作“已完成扫描和标记”，因此其子对象不会被标记。上图中`nextTAMS`和`top`之间的对象J和K就是在标记过程中新生成的对象。因为它们的引用关系在标记开始时并不存在，所以它们都会被当作存活对象。因此，也不必专门为标记过程中新生成的对象创建标记位图。

另外，如果在并发标记的过程中对象的域上发生了写操作，就必须以某种方式记录下改写之前的引用关系。G1GC通过对汤浅的算法稍加优化而得到的写屏障技术，实现了这个功能。因为优化后的写屏障是用于SATB的，因此我们称之为**SATB专用写屏障**。SATB专用写屏障伪代码如下所示：

```
def satb_write_barrier(field, newobj):
    if $gc_phase == GC_CONCURRENT_MARK:
        oldobj = *field
        if oldobj != Null:
            enqueue($current_thread.stab_local_queue, oldobj)
        *field = newobj
```

参数`field`表示被写入对象的域，参数`newobj`表示被写入域的值。`GC_CONCURRENT_MARK`用来表示并发标记阶段的标志位(flag)。检查当前是否处于并发标记阶段且被写入之前`field`域的值是不是Null。如果检查通过，则将`oldobj`添加到`$current_thread.stab_local_queue`中。然后进行实际的写入操作。

这个算法没有对`oldobj`进行任何标记处理，这一点和汤浅的算法不同。原生算法会在第4行检查`oldobj`是否带标记，然后在第5行进行标记，但G1GC的这个算法不会对`oldobj`进行标记。

另外，在实现SATB专用写屏障的实现考虑到了多线程环境下的执行。其中`$current_thread.stab_local_queue`(SATB本地队列)。`$current_thread.stab_local_queue`是mutator各自持有线程本地队列，而非全局的队列，因此在执行`enqueue()`时不用担心线程之间会发生资源竞争。

SATB本地队列会在装满(默认大小1KB)之后，会被添加到全局的SATB队列集合中。这些被添加的SATB本地队列，都是并发标记阶段的待标记对象。

![alt text](/assets/img/G1GC/SATB队列集合和SATB本地队列.png)

在并发标记阶段，GC线程会定期检查SATB队列集合的大小。如果发现其中有队列，则会对队列中的全部对象进行标记和扫描。由于SATB专用写屏障不会检查目标对象是否被标记，因此队列中可能存在已经被标记的对象。这些已经被标记的对象不会再次被标记和扫描。

另外，比起从根开始逐一扫描存活对象并进行标记的处理，扫描SATB队列集合的处理优先级更高。这是因为写屏障会不断地往SATB本地队列中添加对象，但是对象间引用关系地变化并不会改变存活对象地触达链路的总条数。因此，扫描SATB队列集合，比扫描存活对象触达链路的优先级更高也是合理的。

#### SATB 专用写屏障的优化

和汤浅的算法相比，SATB专用写屏障有以下两点不同之处：

1. 不检查目标对象是否被标记
2. 不对目标对象进行标记

但是1和2的处理并不是消失了，而是由GC线程在并发标记过程中处理了。这样做就可以减少写屏障的开销，增加并发标记的开销。

这种优化的目的，在于将写屏障的系统负荷转移到并发标记处理中，从而分担mutator的负担。因为mutator会频繁地执行写屏障，所以减少写屏障地开销也会减轻mutator地负担。而且，并发标记处理是由GC线程和mutator并发执行的，所以多个mutator就能平摊这些负担，进而减轻单个mutator的负担。

如果把这些优化放到不支持并发标记的GC中，该GC的负荷反而会增加，这种针对写屏障的优化，可以说是专为采用了并发标记的G1GC设计的。

#### SATB专用写屏障和多线程执行

```
def satb_write_barrier(field, newobj):
    if $gc_phase == GC_CONCURRENT_MARK:
        oldobj = *field // (a)
        if oldobj != Null:
            enqueue($current_thread.stab_local_queue, oldobj) // (b)
        *field = newobj // (c)
```

这段代码会在各mutator的对象发生改写时被调用执行。但是，代码中(a)到(c)的步骤并没有加锁，所以如果多个线程同时改写域`*field`，`oldobj`就可能会存入意想不到的值。

例如：

- `*field`的值是`obj0`(对象的地址)
- t1(线程1)想要往`*field`中写入`obj1`
- t2(线程2)想要往`*field`中写入`obj2`

如果线程1和线程2按照先后顺序执行，那么t1会往SATB本地队列中写入`obj0`，t2会写入`obj1`。但是t1和t2也有可能按照以下顺序执行。

1. t1执行(a):`oldobj=obj0`
2. t2执行(a):`oldobj=obj0`
3. t1执行(b):`obj0`被添加到`$current_thread.stab_local_queue`中
4. t2执行(b):`obj0`被添加到`$current_thread.stab_local_queue`中
5. t1执行(c):`*field=obj1`
6. t2执行(c):`*field=obj2`

在这种情况下，`*field`最终会被t2写入`obj2`。但是t1写入的`obj1`并不会被添加到SATB本地队列中。也就是说，`obj1`并没有被SATB专用写屏障获知。这看起来像是致命的缺陷，但实际上，即使`obj1`没有被添加到SATB本地队列也没关系。

SATB专用写屏障本来是用来防止发生标记遗漏的，那么`obj1`没有被添加到SATB本地队列这件事会不会导致标记遗漏呢？

![alt text](/assets/img/G1GC/obj1未被SATB专用写屏障获知时对象之间的关系.png)

上图表示的是`obj1`未被SATB专用写屏障获知时对象之间的关系。我们假定并发标记进行到了`obj3`。由于`obj1`不会被添加到SATB本地队列中，所以会保持为白色。而`obj0`会被添加到SATB本地队列中，所以会变成灰色。但是在后续扫描`obj4`时，`obj1`最终还是会被标记，所以不存在标记遗漏。

那么，如果`obj1`不再被`obj4`引用，而变为被`obj2`引用时，情况又是怎样的呢？

![alt text](/assets/img/G1GC/obj1不再被obj4引用，变为被obj2引用时对象之间的关系.png)

在这种情况下，来自`obj4`的引用消失会被SATB专用写屏障获知，`obj1`会变成灰色，所以也不会有问题。

SATB专用写屏障会记录下并发标记阶段开始时对象之间的引用关系。这么来看，因为`obj3`对`obj1`的引用在并发标记阶段开始时并不存在，所以根本没有必要记录`obj1`。相反，因为`obj3`对`obj0`的引用在并发标记阶段开始时就存在，所以记录`obj0`是有必要的。

(a)到(c)的步骤虽然没有加锁，但是SATB专用写屏障技术严格遵守了前面这些约束条件，所以即使不记录`obj1`也是没有问题的。

### 最终标记阶段

最终标记阶段的处理是暂停处理，需要暂停mutator的运行。

因为未装满的SATB本地队列不会被添加到SATB队列集合中，所以在并发标记阶段结束后，各个线程的SATB本地队列中可能仍然存在待扫描的对象。而最终标记阶段就会扫描这些“残留的SATB本地队列”。下图中，队列中保存了对象G和H的引用。因此在扫描SATB本地队列之后，对象G和H，以及对象H的子对象I都会被标记。

![alt text](/assets/img/G1GC/最终标记阶段结束后区域的状态.png)

本步骤结束后，所有的存活对象都已被标记。因此，此时所有不带标记的对象都可以判定为死亡对象。

因为SATB本地队列中的数据会被mutator操作，所以本步骤不能和mutator并发执行。

### 存活对象计数

这个步骤会扫描各个区域的标记位图`next`，统计区域内存活对象的字节数，然后将其存入区域内的`next_marked_bytes`。下图中的存活对象是A、C、E、G、H和I，因此计算出的总字节数56会被存入`next_marked_bytes`中。对象E虽然只有头部的1个比特被标记了，但参与统计的是它的真实大小，即16字节。

![alt text](/assets/img/G1GC/存活对象计数结束后区域的状态.png)

另外，我们假设在计数过程中新创建了对象L和M。由于这些包含在`nextTAMS`和`top`之间的对象会被当作存活对象来处理，所以不会在这里特意进行计数。

`prev_marked_bytes`中存放了上次标记结束时存活对象的字节数。上图中的区域在此之前未曾进行过标记，因此`prev_marked_bytes`中存放的是初始值0。

计数处理和mutator是并发执行的。但是，计数过程中操作的对象也可能会被转移的记忆集合(remembered set)线程使用，因此需要先停掉记忆集合线程。

另外，转移处理也可能在计数过程中启动。这时，需要先将正在计数中的区域统计完，再开始转移处理。已完成计数的区域在转移后会变成空区域，所以`next_marked_bytes`也会变成0。而转移目标区域内都是存活对象，所以也不会对它进行计数。

### 收尾工作

收尾工作所操作的数据中有些是和mutator共享的，因此需要暂停mutator的运行。

在此期间GC线程会逐个扫描每个区域，将标记位图`next`中的并发标记结果移动到标记位图`prev`中，再对并发标记中使用过的标记值进行重置，为下次并发标记做好准备。

此外，对没有存活对象的区域进行回收的工作也在这个时候进行。可以把它理解成以区域为单位进行的清除处理。

在扫描过程中还会计算每个区域的**转移效率**，并按照该效率对区域进行降序排序。

下图展示了收尾工作结束后区域的状态。上图里的`next next_marked_bytes`中的值被移到了`prev prev_marked_bytes`中。同时，`prevTAMS`被移到了`nextTAMS`先前的位置。`prevTAMS`表示的是“上次并发标记开始时`top`的位置”。

![alt text](/assets/img/G1GC/收尾工作完成后区域的状态.png)

`next next_marked_bytes`也会被重置，同时`nextTAMS`会移动到`bottom`的位置。`nextTAMS`会在下次并发标记开始时，移动到`top`的最新位置。

收尾工作结束后，整个并发标记就结束了。并发标记线程会一直处于等待状态，直到下次并发标记开始。

#### 转移效率

转移效率可以通过公式“死亡对象的字节数÷转移所需时间”来计算。换句话说，转移效率指的就是**转移1个字节所需的时间**。区域的转移效率可以通过公式“区域内死亡对象的字节数÷转移整个区域所需时间”来计算。

这里的“转移所需时间”严格来说是**转移的预测时间**。转移的预测时间可以根据过去的实际转移时间来计算。

另外，一般来说死亡的对象越多，转移效率就越高。死亡对象多就意味着存活对象少；存活对象越少，转移所需的时间就越少，所以转移效率就会越高。

