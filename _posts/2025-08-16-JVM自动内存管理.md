---
title: JVM虚拟机
date: 2025-08-16 10:00:00 +0800
categories: [Java, JVM]
tags: [study]     # TAG names should always be lowercase
author: momochi
description: JVM虚拟机概述
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

## JVM运行时数据区域(内存结构)

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，

![alt text](/assets/img/jvm/运行时数据区域.png)

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型中，字节码解释器工作时，通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(如果是多核处理器就是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

如果线程正在执行的一个是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，这个计数器值应为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### Java虚拟机栈

和程序计数器一样，Java虚拟机栈也是线程私有的，生命周期与线程相同，虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应一个栈帧入栈出栈的过程。

在局部变量表中，存放了编译器可知的各种Java虚拟机基本数据类型、对象引用和地址。这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小(槽的数量)。

StackOverflowError异常就是线程请求的栈深度大于虚拟机所允许的深度，查看jvm线程栈大小命令如下：

```
java -XX:+PrintFlagsFinal -version | grep ThreadStackSize
java -XX:+PrintFlagsFinal -version | findstr ThreadStackSize
```

结果如下图所示：

![alt text](/assets/img/jvm/ThreadStackSize.png)

其中`{pd ergo}`表示平台默认，通常64位JVM的默认线程栈(虚拟机栈，该说法用来强调每个线程都有自己的栈)大小为1MB。

设置线程栈大小命令如下：

```
java -Xss512k MyApp
```

以下为一个出发StackOverflowError简单示例：

```java
public class StackOverflowDemo {

    // 无限递归函数
    public static void recallMethod() {
        recallMethod();
    }

    public static void main(String[] args) {
        recallMethod();
    }
}
```

OutOfMemoryError则是在无法申请到足够内存时抛出，而在HotSpot虚拟机上，Java虚拟机栈容量是不会动态扩展的，因此只要在线程申请栈空间时成功就不会出现OutOfMemoryError。

由此，我们可以知道线程栈内存大小是在JVM启动时确定的，在HotSpot虚拟机上，虚拟机栈容量不会动态扩展，那么完全可以在不同情况下设置相应的ThreadStackSize来控制线程申请的内存来减少内存消耗。

例如，线程栈大小1MB，如果创建了1000个线程，即使什么都不做，JVM也会预留 $$1000\times 1MB = 1GB$$的虚拟内存。虽然这部分不会立即占用物理内存，但是会增加进程的虚拟地址空间占用，并且可能触发OutOfMemoryError，因为上面说到线程申请内存时失败就会抛出该Error，那么在极端情况下，线程申请不到1MB的时候可能就会出现`OutOfMemoryError: unable to create new native thread`。

因此，我们可以在保证程序正常运行(不触发`StackOverflowError`)的前提下，减小每个线程栈大小，从而降低整体内存占用。相应的，对于深度递归、复杂解析的任务，也可以适当增加线程栈大小来避免触发`StackOverflowError`。

### 本地方法栈

本地方法栈与虚拟机栈发挥的作用是非常相似的，其区别只是虚拟机栈作为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。

虚拟机规范对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机(如HotSpot)直接就把本地方法栈和虚拟机栈合二为一，与虚拟机栈一样，本地方法栈也会在栈深度溢出或栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError。

### 堆

对于Java的应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，Java中几乎所有的对象实例都在这里分配内存，在虚拟机规范中对Java堆的描述是“所有的对象实例以及数组都应当在堆上分配”，而这里的几乎，是因为会有逃逸分析，栈上分配、标量替换优化手段。

Java堆是垃圾收集器管理的内存区域，因此也称为“GC堆”，从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些区域划分仅仅是一部分垃圾收集器的共同特性或者设计风格，而并非某个Java虚拟机具体实现的固有内存布局，更不是虚拟机规范里对Java堆的进一步细分。

从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)，以提升对象分配时的效率。不过，无论从什么角度，怎么划分，都不会改变Java堆中存储内容的共性。存储的都只是对象实例。将Java堆细分只是为了更好地回收内存，或者更快地分配内存。

根据虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象(如数组)，多数虚拟机实现出于简单、存储高效的考虑，很可能要求连续的存储空间。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数-Xmx和-Xms设定)。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机会抛出OutOfMemoryError。

-Xms，设置JVM启动时的初始堆大小。-Xmx设置JVM可扩展到的最大堆大小。

显然，以上两个设置，在只设置一个设置的情况下，可能会出现，例如设置了-Xmx，但是-Xms默认值很小，那么会导致初期频繁Minor GC，扩展的时候出现Full GC。

### 方法区

方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然虚拟机规范中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是和Java堆区分。

方法区和永久代并不是等价的，因为在JDK8之前当时的HotSpot虚拟机设计选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这一部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受虚拟机规范管束。

而使用永久代来实现方法区的设计，导致了Java应用更容易遇到内存溢出的问题(永久代有-XX:MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会有问题)，而且有极少数方法(例如`String:intern()`)会因为永久代的原因导致不同虚拟机下有不同的表现。因此在JDK6的时候HotSpot就有放弃永久代，逐步改为采用本地内存(Native Memory)来实现方法区的计划。JDK7的HotSpot已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来代替，把JDK7中永久代剩下的内容全部移到元空间中。

虚拟机规范对方法区的约束非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确比较少出现，但并非数据进入了方法区就如永久代的名字一样永久存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

根据虚拟机规范规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError。

### 运行时常量池

运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中。

Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定。如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，虚拟机规范并没有任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Jaava语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入常量池中，例如`String.intern()`方法。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError。

但是在JDK7开始，HotSpot字符串对象被移到堆中，字符串常量在元空间中只存储引用，那么就避免了`String.intern()`导致的OutOfMemoryError的问题。

```java
public class StringInHeap {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = new String("hello").intern();

        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // true

        // 打印对象哈希码（基于地址）
        System.out.println("s1 hash: " + System.identityHashCode(s1));
        System.out.println("s2 hash: " + System.identityHashCode(s2));
    }
}
```

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError出现。

在JDK1.4中新加入NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据。

显然，本机直接内存的分配不会受到Java堆大小的限制，但是，肯定会受到本机总内存(物理内存、SWAP分区或分页文件)大小及处理器寻址空间的限制，直接内存也可能会出现OutOfMemoryError。

### 元空间

元空间主要包含以下内容：

1. 类的结构信息
2. 方法信息
3. 字段信息
4. 运行时常量池
5. 注解信息
6. 方法表
7. JIT编译后的代码缓存(一部分)
8. 类加载器引用
9. 内部字符串

HotSpot使用`InstanceKlass`来表示一个Java类，以下为其中字段部分：

```cpp
class InstanceKlass : public Klass {
  Symbol* _name;                // 类名，如 "java/lang/String"
  Array<Method*>* _methods;     // 方法数组
  Array<Field*>* _fields;       // 字段数组
  ConstantPool* _constants;     // 运行时常量池
  Klass* _super;                // 父类
  Annotations* _annotations;    // 类的注释
  Klass* _array_klasses;        // 包含类元素的数组类。
  // ...
};
```

如此，在一个Java类中：

```java
public class Config {
    public static final String ENV = "prod";
    public static User ADMIN = new User("admin");
}
```

其中ENV的引用和ADMIN的引用存储在元空间中，字符串对象和User实例都在Java堆中存储。元空间只存储引用，实例都在Java堆中。

### Java堆溢出

Java堆用于存储对象实例，只要我们不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生OutOfMemoryErrorr。

如下，我们先设置`-Xmx1024K -Xms1024K`，然后运行就会抛出`Exception in thread "main" java.lang.OutOfMemoryError: Java heap space`

```java
public class HeapOOM {
    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<OOMObject>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

在实际使用中，我们要区分是内存泄漏还是内存溢出，如果是内存泄漏可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径，与哪些GC Roots关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及到GC Roots引用链的信息，一般可以较准确定位到这些对象创建的位置。

如果不是内存泄漏，也就是说这些内存中的对象都是必须存活的，那就应当检查Java虚拟机的`-Xmx`和`-Xms`设置，是否能够向上调整，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

### 线程栈和本地方法栈溢出

HotSpot并不区分线程栈和本地方法栈，因此对于HotSpot来说`-Xoss`参数实际无效，栈容量只能通过`-Xss`参数设定。上面说到线程请求的栈深度大于虚拟机所运行的最大深度，将会抛出StackOverflowError。栈内存申请时失败会抛出OutOfMemoryError，如果支持动态扩展，扩展时容量无法申请也会抛出OutOfMemoryError。

使用-Xss参数减少栈内存容量：

```java
public class JavaVMStackSOF {
    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            throw e;
        }
    }
}
```

```
stack length:15317
Exception in thread "main" java.lang.StackOverflowError
...
```

定义大量本地变量，增大该方法帧中本地变量表的长度：

```java
public class JavaVMStackSOF {
    private static int stackLength = 0;

    public static void test() {
        long unused1, unused2, unused3, unused4, unused5,
                unused6, unused7, unused8, unused9, unused10,
                unused11, unused12, unused13, unused14, unused15,
                unused16, unused17, unused18, unused19, unused20,
                unused21, unused22, unused23, unused24, unused25,
                unused26, unused27, unused28, unused29, unused30,
                unused31, unused32, unused33, unused34, unused35,
                unused36, unused37, unused38, unused39, unused40,
                unused41, unused42, unused43, unused44, unused45,
                unused46, unused47, unused48, unused49, unused50,
                unused51, unused52, unused53, unused54, unused55,
                unused56, unused57, unused58, unused59, unused60,
                unused61, unused62, unused63, unused64, unused65,
                unused66, unused67, unused68, unused69, unused70,
                unused71, unused72, unused73, unused74, unused75,
                unused76, unused77, unused78, unused79, unused80,
                unused81, unused82, unused83, unused84, unused85,
                unused86, unused87, unused88, unused89, unused90,
                unused91, unused92, unused93, unused94, unused95,
                unused96, unused97, unused98, unused99, unused100;
        stackLength++;
        test();
        unused1 = unused2 = unused3 = unused4 = unused5 =
                unused6 = unused7 = unused8 = unused9 = unused10 =
                        unused11 = unused12 = unused13 = unused14 = unused15 =
                                unused16 = unused17 = unused18 = unused19 = unused20 =
                                        unused21 = unused22 = unused23 = unused24 = unused25 =
                                                unused26 = unused27 = unused28 = unused29 = unused30 =
                                                        unused31 = unused32 = unused33 = unused34 = unused35 =
                                                                unused36 = unused37 = unused38 = unused39 = unused40 =
                                                                        unused41 = unused42 = unused43 = unused44 = unused45 =
                                                                                unused46 = unused47 = unused48 = unused49 = unused50 =
                                                                                        unused51 = unused52 = unused53 = unused54 = unused55 =
                                                                                                unused56 = unused57 = unused58 = unused59 = unused60 =
                                                                                                        unused61 = unused62 = unused63 = unused64 = unused65 =
                                                                                                                unused66 = unused67 = unused68 = unused69 = unused70 =
                                                                                                                        unused71 = unused72 = unused73 = unused74 = unused75 =
                                                                                                                                unused76 = unused77 = unused78 = unused79 = unused80 =
                                                                                                                                        unused81 = unused82 = unused83 = unused84 = unused85 =
                                                                                                                                                unused86 = unused87 = unused88 = unused89 = unused90 =
                                                                                                                                                        unused91 = unused92 = unused93 = unused94 = unused95 =
                                                                                                                                                                unused96 = unused97 = unused98 = unused99 = unused100 = 0;
    }

    public static void main(String[] args) {
        try {
            test();
        } catch (Error e) {
            System.out.println("stack length:" + stackLength);
            throw e;
        }
    }
}

```


```
stack length:597
Exception in thread "main" java.lang.StackOverflowError
...
```

以上结果说明无论是由于栈帧太大还是线程栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError。

## GC

Lisp是第一门开始使用内存动态分配和垃圾收集技术的语言，以下为垃圾收集需要完成的三件事情：

- 哪些对象需要回收？
- 什么时候回收？
- 如何回收？

前面介绍了Java运行时内存区域各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域生命周期与线程一致，每一个栈帧分配多少内存基本在类结构确定下来时就已知了(虽然运行时可能会由即时编译器优化，但是大体上可以认为编译期可知)，因此这几个区域的内存分配和回收都具备确定性，即不需要过多考虑如何回收。

而Java堆和方法区具有很明显的不确定性，一个接口的多个实现类需要的内存可能不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有在运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存如何管理。

### 引用计数

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是并不可能再被使用的。

虽然引用计数会占用一些额外的内存空间来进行计数，但是原理简单，判定效率高。但在Java，主流的Jaav虚拟机都没有使用引用计数来管理内存，因为会有很多例外情况需要考虑，还需要大量额外的处理才能保证其能够正确地工作，例如单纯的引用计数很难解决对象之间相互循环引用的问题。

我们来创建一个循环引用的对象，然后将引用去除(即没有任何地方引用这两个实例，除了他们互相的引用)

```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    }
}
```

```
[GC (System.gc()) [PSYoungGen: 9257K->816K(150016K)] 9257K->824K(493056K), 0.0009175 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 816K->0K(150016K)] [ParOldGen: 8K->595K(343040K)] 824K->595K(493056K), [Metaspace: 3407K->3407K(1056768K)], 0.0028721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 150016K, used 6451K [0x0000000718b80000, 0x0000000723280000, 0x00000007c0000000)
  eden space 129024K, 5% used [0x0000000718b80000,0x00000007191cce68,0x0000000720980000)
  from space 20992K, 0% used [0x0000000720980000,0x0000000720980000,0x0000000721e00000)
  to   space 20992K, 0% used [0x0000000721e00000,0x0000000721e00000,0x0000000723280000)
 ParOldGen       total 343040K, used 595K [0x00000005ca200000, 0x00000005df100000, 0x0000000718b80000)
  object space 343040K, 0% used [0x00000005ca200000,0x00000005ca294cc0,0x00000005df100000)
 Metaspace       used 3421K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 365K, capacity 388K, committed 512K, reserved 1048576K
```

从上面的GC日志看，相互引用的对象被回收掉了，如此也能说明Java并未使用引用计数的方法进行垃圾回收。

### 可达性分析

基本思路通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Roots到该对象不可达，则可以证明该对象不可能再被使用。

![alt text](/assets/img/jvm/reference-chain.png)

可作为GC Roots的对象包括以下几种：

- 在虚拟机栈(栈帧中的本地变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等。
- 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，例如字符串常量池(String Table)里的引用。
- 在本地方法栈中JNI引用的对象。
- Java虚拟机内部的引用，例如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器。
- 所有被同步锁(`synchronized`)持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVM TI中注册的回调，本地代码缓存等。

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”加入，构成完整的GC Roots集合。

### 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，它建立在两个分代假说之上：

1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过多次垃圾收集过程的对象就越难以消亡

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(即熬过垃圾收集过程的次数)分配到不同的区域之中存储。显然，如果一个区域中的大多数对象都会很快消亡，那么把它们集中放在一起，每次回收时只需要关注如何保留少量存活的而不是去标记那些大量将要被回收的对象，就能以较低代价回收大量空间。同样，如果剩下的都是难以消亡的对象，把它们集中放在一块，虚拟机便能以较低的频率来回收这一个区域。

那么在Java堆划分了不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分。也才能针对不同的区域安排与之相匹配的垃圾收集算法——“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。

然而，想要分代收集并不只需要简单划分内存区域，还有一个明显的问题：对象之间跨代引用。例如，现在要进行一次只限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象带来了很大的性能负担。

跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

存在互相引用关系的两个对象，是应该倾向于同时生存或同时消亡的。例如，某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用的问题也随即被消除了。

那么，根据这条假说，我们就不需要为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需要在新生代上建立一个全局数据结构(记忆集,Remembered Set)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存存在跨代引用，后面发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots扫描。

以G1为例。`G1RemSet`是G1收集器的全局记忆集管理器。

```cpp
class G1RemSet: public CHeapObj<mtGC> {
private:
  // 每个 HeapRegion 有一个对应的 Remembered Set
  HeapRegionRemSet** _rsets;

  // 全局并发处理线程
  G1RemSetTrackingThread* _tracking_thread;

public:
  // 向某个 Region 的 RSet 中添加引用
  void add_reference(void* from, int worker_i);

  // 初始化 RSet
  void init();

  // 并发扫描 Card Table，构建 RSet
  void update_rem_set(G1ParPushHeapRSClosure* push_rem,
                      G1ParScanThreadState* pss);
};
```

每个`HeapRegion`都有一个`HeapRegionRemSet`记录谁引用了它。

```cpp
class HeapRegionRemSet: public CHeapObj<mtGC> {
private:
  // 使用 BitMap 或 SparseTable 存储引用
  union {
    BitMap* _bm;
    SparseHashtable* _st;
  } _entries;

  // RSet 类型：Sparse（稀疏）、Fine（细粒度）、Coarse（粗粒度）
  RefType _type;

public:
  // 添加一个引用（from 指向当前 Region）
  void add_reference(void* from);

  // 扫描 RSet 中的引用
  void iterate(FilteredClosure* cl);
};
```

在老年代对象修改引用时：

```cpp
void G1SATBCardTableModRefBS::enqueue(oop pre_val) {
  // Nulls should have been already filtered.
  assert(pre_val->is_oop(true), "Error");

  if (!JavaThread::satb_mark_queue_set().is_active()) return;
  Thread* thr = Thread::current();
  if (thr->is_Java_thread()) {
    JavaThread* jt = (JavaThread*)thr;
    jt->satb_mark_queue().enqueue(pre_val);
  } else {
    MutexLockerEx x(Shared_SATB_Q_lock, Mutex::_no_safepoint_check_flag);
    JavaThread::satb_mark_queue_set().shared_satb_queue()->enqueue(pre_val);
  }
}
```

### 标记-清除算法

如名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。有两个主要的缺点：第一个是执行效率不稳定，如果Java堆中包含了大量对象，而且其中大部分是需要回收的，这时必须进行大量标记和清除的动作(上面也说过，例如新生代中我们并不用关注哪些对象要消亡，而是关注较少的部分——哪些对象存活)，导致标记和清除两个过程的执行效率随着对象数量增长而降低；第二个是内存空间碎片化，标记、清除后会产生大量不连续的碎片，空间碎片太多可能导致后续程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。

### 标记-复制算法

上面说到标记-清除在面对大量对象时执行效率低的问题，标记-复制将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只需要移动堆顶指针，按顺序分配即可。实现简单，运行高效，但缺点也明显，因为将可使用内存分为两块，空间浪费太多了。

但是因为上面讲到分代收集，我们完全可以在符合存活对象少的区域使用该标记-复制算法，例如在新生代中使用标记-复制算法，并且IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集，因此我们完全可以不按照对半来划分新生代的内存空间。即如Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也即每次新生代中可用内存空间为整个新生代容量的90%，只有10%是被“浪费”的。当然，上面说到的98%对象被回收，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此还有一个安全设计，当Survivor空间不足以容纳Minor GC之后存活的对象时，就需要靠其他内存区域(大多数时候是老年代)进行分配担保。

### 标记-整理算法

标记-复制在对象存活率较高时就需要进行较多的复制操作，效率将会降低。并且不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都是100%存活的极端情况，所有在老年代一般不能直接使用这种算法。

标记-整理过程和“标记-清除”一样，但后续步骤不会直接对回收对象进行清理，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。和标记-清除本质差异在于清除是非移动式的回收算法，整理是移动式的回收算法，如果移动存活对象，那么移动存活对象并更新所有引用这些对象的地方是极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行。但如果使用标记-清除的话，虽然不需要移动，但是会产生空间碎片化的问题，只能依赖更复杂的内存分配器和内存访问器来解决。

基于以上，移动和不移动都存在弊端，移动则内存回收更复杂，不移动则内存分配更复杂。从停顿时间来看，不移动对象停顿时间更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。即使不移动对象会提升收集器效率，但是带来的内存分配和访问问题相比垃圾收集频率要大。那么这里就需要做出相应取舍，例如关注吞吐量的收集器使用标记-整理，关注延迟的收集器则可以使用标记-清除。

## 内存分配与回收策略

自动内存管理，最根本目标是自动化解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下(例如对象大小超过一定阈值)也可能会直接分配在老年代，对象分配的规则并不是固定的，虚拟机规范并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪一种垃圾收集器，以及虚拟机中与内存相关的参数的设定。

### 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

HotSpot虚拟机提供了`-XX:+PrintGCDetails`这个收集器日志参数，在发生垃圾收集行为时会打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。

以下尝试分配三个2MB大小和一个4MB大小的对象，在运行时通过设置`-Xms20M -Xmx20M -Xmn10M`三个参数限制Java堆大小为20MB，不可扩展，其中10MB分给新生代，剩下10MB分给老年代。`-XX:Survivor-Ratio=8`决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果可以看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代一共可用空间为9MB。

执行后，分配allocation4对象的语句会发生一次Minor GC，这次回收的结果是新生代6651KB变为148KB，

```java
public class TestAllocation {
    private static final int _1MB = 1024 * 1024;

    /**
     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
     */
    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB]; // 出现一次Minor GC
    }

    public static void main(String[] args) {
        testAllocation();
    }
}
```

```
Heap
 PSYoungGen      total 9216K, used 7969K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 97% used [0x00000000ff600000,0x00000000ffdc8740,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 10240K, used 4096K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff000010,0x00000000ff600000)
 Metaspace       used 3434K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 367K, capacity 388K, committed 512K, reserved 1048576K
```

### 大对象直接进入老年代

大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量庞大的数组，以下以`byte[]`为例。大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象还坏的就是这些大对象存活时间很短。在分配空间时，容易导致内存明明还有不少空间时就触发垃圾收集，以获取足够的连续空间安置，同样，复制时，也就意味着高额的内存复制开销。HotSpot虚拟机提供了`-XX:PretenureSizeThreshold`参数，指定大于该设置值的对象直接进老年代分配，目的就是避免在Eden区和两个Survivor区来回复制，产生大量内存复制操作。

上面说到的参数只对Serial和ParNew两款新生代收集器有效，HotSpot的其他新生代收集器，如Parallel Scavenge不支持该参数。

```java
public class TestPretenureSizeThreshold {
    private static final int _1MB = 1024 * 1024;
    /**
     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
     * -XX:PretenureSizeThreshold=3145728
     */
    public static void testPretenureSizeThreshold() {
        byte[] allocation;
        allocation = new byte[4 * _1MB]; //直接分配在老年代中
    }

    public static void main(String[] args) {
        testPretenureSizeThreshold();
    }
}
```

```
Heap
 def new generation   total 9216K, used 1825K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  22% used [0x00000000fec00000, 0x00000000fedc8710, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)
 Metaspace       used 3434K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 367K, capacity 388K, committed 512K, reserved 1048576K
```

### 长期存活的对象进入老年代

HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且其对象年龄设为1岁。对象在Survivor区每熬过一次Minor GC，年龄就增加1岁，当增加到一定程度(默认15)，就会被晋升到老年代。可以通过参数`-XX:MaxTenuringThreshold`设置。

```java
public class TestTenuringThreshold {
    private static final int _1MB = 1024 * 1024;
    /**
     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+UseSerialGC 
     * -XX:+PrintTenuringDistribution
     */
    @SuppressWarnings("unused")
    public static void testTenuringThreshold() {
        byte[] allocation1, allocation2, allocation3;
        allocation1 = new byte[_1MB / 4]; // 什么时候进入老年代决定于XX:MaxTenuring-
        allocation2 = new byte[4 * _1MB];
        allocation3 = new byte[4 * _1MB];
        allocation3 = null;
        allocation3 = new byte[4 * _1MB];
    }

    public static void main(String[] args) {
        testTenuringThreshold();
    }

}
```

```
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
- age   1:     912296 bytes,     912296 total
: 6186K->890K(9216K), 0.0021996 secs] 6186K->4986K(19456K), 0.0022432 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 1)
: 4986K->0K(9216K), 0.0010631 secs] 9082K->4976K(19456K), 0.0010826 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4335K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff03bdc0, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 4976K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  48% used [0x00000000ff600000, 0x00000000ffadc3a8, 0x00000000ffadc400, 0x0000000100000000)
 Metaspace       used 3434K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 367K, capacity 388K, committed 512K, reserved 1048576K
```

```
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 1 (max 15)
- age   1:     868448 bytes,     868448 total
: 6013K->848K(9216K), 0.0019886 secs] 6013K->4944K(19456K), 0.0020168 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 524288 bytes, new threshold 15 (max 15)
- age   1:      21512 bytes,      21512 total
: 5028K->21K(9216K), 0.0005660 secs] 9124K->4963K(19456K), 0.0005930 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4494K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  54% used [0x00000000fec00000, 0x00000000ff05e420, 0x00000000ff400000)
  from space 1024K,   2% used [0x00000000ff400000, 0x00000000ff405408, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 4942K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  48% used [0x00000000ff600000, 0x00000000ffad3800, 0x00000000ffad3800, 0x0000000100000000)
 Metaspace       used 3405K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 362K, capacity 388K, committed 512K, reserved 1048576K
```

其中`allocation1`需要256KB内存，Survivor区可以容纳。当设置年龄为1就放到老年代时，`allocation1`对象在第二次GC发生时进入老年代，新生代已使用的内存在垃圾收集后变为0KB。

### 动态对象年龄判断

为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX:MaxTenuringThreshold中要求的年龄。

从上一个案例晋升日志即可发现，年龄是动态的。


### 空间分配担保

在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总
空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看XX:HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。

上面说到，新生代使用复制收集，只使用其中一个Survivor空间作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况，需要老年代进行分配担保，把Survivor无法容纳的对象直接放入老年代，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

但根据历史平均值比较还是一个概率解决办法，也就是说假如某次Minor GC存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只好老老实实地重新发起一次Full GC，这样停顿时间就很长了。虽然担保失败时绕的圈子是最大的，但通常情况下都还是会将-XX：HandlePromotionFailure开关打开，避免Full GC过于频繁。在JDK6后该参数不再可配置，JVM会根据老年代可用空间、历代晋升大小等数据动态决策。

## Class文件

![alt text](/assets/img/jvm/class-file.png)

![alt text](/assets/img/jvm/class-bytecode.png)

### 常量池

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比
较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：

- 被模块导出或者开放的包（Package）
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
- 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK13，常量表中分别有17种不同类型的常量。

这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位（tag，标志），代表着当前常量属于哪种常量类型。

![alt text](/assets/img/jvm/constant-pool-type.png)

## 类加载

### 加载时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。请注意，这里笔者写的是按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。

什么情况下需要开始“加载”阶段，虚拟机规范中并未强制约束，但是“初始化”阶段，虚拟机规范严格规定有且只有六种情况必须立即对类进行“初始化”(当然在这之前也需要加载、验证、准备)

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
    - 使用new关键字实例化对象的时候。
    - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）
的时候。
    - 调用一个类型的静态方法的时候
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

```java
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}


public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

public class TestNotInitialization {

    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}

```

可以看见只会输出“SuperClass init”，。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。对于HotSpot虚拟机来说，可通过`-XX:+TraceClassLoading`参数观察到此操作是会导致子类加载的。

```java
public class TestNotInitialization {

    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```

运行之后发现没有输出“SuperClassinit！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。

### 加载过程

这里“加载”是整个“类加载”过程中一个阶段。在该阶段Java虚拟机需要完成三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

虚拟机规范对这三点要求都不是很具体，例如第一点并没有指定获取来源必须是Class文件，那么完全可以从压缩包读取，Jar、EAR、WAR。还可以从网络中获取，运行时计算生成，数据库读取等等。

相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。

对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：

- 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上（这点很重要，在7.4节会介绍，一个类型必须与类加载器一起确定唯一性）。
- 如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。

验证时连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。大致完成四个阶段：文件格式验证、元数据验证、字节码验证和符号引用验证。

准备阶段是正式称为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值的阶段。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。

准备阶段，这时候进行内存分配的仅包括类变量，而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在Java堆中。

```java
public static int value = 123;
```

变量`value`在准备阶段过后的初始值为0而不是123，因为这时未开始执行任何Java方法，而把`value`赋值123的putstatic指令是程序被编译后，存放在类构造器`<clinit>()`方法中。所以赋值应在类初始化阶段执行。

但如果该变量如下定义：

```java
public static final int value = 123;
```

类字段的字段属性表中存在ConstantValue属性，在准备阶段变量值就会被初始化为ConstantValue属性指定的初始值。准备阶段该`value`被赋值123。

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？

初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。

在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器`<clinit>()`方法的过程。`<clinit>()`并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物：

- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
- `<clinit>()`方法与类的构造函数（即在虚拟机视角中的实例构造器`<init>()`方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的`<clinit>()`方法执行前，父类的`<clinit>()`方法已经执行完毕。因此在Java虚拟机中第一个被执行的`<clinit>()`方法的类型肯定是java.lang.Object。
- 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
- `<clinit>()`方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
- Java虚拟机必须保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行完毕`<clinit>()`方法。如果在一个类的`<clinit>()`方法中有耗时很长的操作，那就可能造成多个进程阻塞

```java
public class TestClinit {
    static {
        i = 0;
        System.out.println(i); // 该处编译器会提示 非法向前引用
    }
    static int i = 1;
}

public class TestClinit {
    static class Parent {
        public static int A = 1;
        static {
            A = 2;
        }
    }
    static class Sub extends Parent {
        public static int B = A;
    }
    public static void main(String[] args) {
        System.out.println(Sub.B); // 输出2
    }
}

public class TestDeadLoop {
    static class DeadLoopClass {
        static {
            // 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译
            if (true) {
                System.out.println(Thread.currentThread() + "init DeadLoopClass");
                while (true) {
                }
            }
        }
    }

    public static void main(String[] args) {
        Runnable script = new Runnable() {
            public void run() {
                System.out.println(Thread.currentThread() + "start");
                DeadLoopClass dlc = new DeadLoopClass();
                System.out.println(Thread.currentThread() + " run over");
            }
        };
        Thread thread1 = new Thread(script);
        Thread thread2 = new Thread(script);
        thread1.start();
        thread2.start();
    }
    //Thread[Thread-0,5,main]start
    //Thread[Thread-1,5,main]start
    //Thread[Thread-0,5,main]init DeadLoopClass
}
```

单例模式





