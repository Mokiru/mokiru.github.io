---
title: 设计模式
date: 2025-03-11 20:00:00 +0800
categories: [Design Pattern]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: 设计模式概述
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---


# 设计模式

## 创建型设计模式

### 单例模式

该模式涉及到单一的类，该类负责创建自己对象，同时确保只有单个对象被创建，并且提供了一种访问唯一对象的方式。
单例模式的类需要满足：
- 只有一个实例
- 自己创建自己的唯一实例
- 必须对外提供获取该实例的接口

对该唯一实例的创建时机分为
1. 懒汉式
2. 饿汉式

#### 懒汉式

即等要使用的时候才去创建，也就是第一次调用`getInstance()`时才去创建实例，同时为了避免在条件判断时出线程安全问题，应如下：

```java
public class Singleton {
    private Singleton(){}

    private static class Handler {
        public static final Singleton instance = new Singleton();
    }

    public static Singleton getInstance() {
        return Handler.instance;
    }
}
```

#### 饿汉式

等不及，一开始加载时就要创建，但这样的好处就是启动时就创建一般不会遇到线程安全问题，也就不用加锁：

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton (){}

    public static Singleton getInstance() {
        return instance;
    }
}
```

#### 枚举

以上方法都有一个缺点，就是当使用反射可以创建其对象：

```java
public class Main {
    public static void main(String[] args) {
        try {
            Class<?> clazz = Singleton.class;
            Constructor<?> constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            Singleton instance = constructor.newInstance();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
```

想要避免这种情况就需要使用枚举类实现，枚举类第一次加载时便会执行构造函数创建实例，因为构造方法是私有的，并且无法通过`new`创建新的实例，如下：

```java
public enum Singleton {
    INSTANCE;    
}
```

但是该方法也有其局限性，枚举类不能继承，只能实现接口，并且是`final`的，无法被其他类继承，那么其扩展性就受到了限制。并且创建时机并不是在`getInstance()`时，而是使用到该枚举类，枚举类第一次加载时就创建，所以不是懒汉式，而想要实现懒汉式的效果需要额外实现：

```java
public enum LazySingleton {
    private static volatile Singleton INSTANCE;

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (LazySingleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }

    private static class Singleton {
        private Singleton(){}
    }
}
```

