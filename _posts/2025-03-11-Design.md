---
title: 设计模式
date: 2025-03-11 20:00:00 +0800
categories: [Design Pattern]
tags: [study]     # TAG names should always be lowercase
author: momochi
# authors: [xx,xx]
description: 设计模式概述
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

## 创建型设计模式

### 单例模式

该模式涉及到单一的类，该类负责创建自己对象，同时确保只有单个对象被创建，并且提供了一种访问唯一对象的方式。
单例模式的类需要满足：
- 只有一个实例
- 自己创建自己的唯一实例
- 必须对外提供获取该实例的接口

对该唯一实例的创建时机分为
1. 懒汉式
2. 饿汉式

#### 懒汉式

即等要使用的时候才去创建，也就是第一次调用`getInstance()`时才去创建实例，同时为了避免在条件判断时出线程安全问题，应如下：

```java
public class Singleton {
    private Singleton(){}

    private static class Handler {
        public static final Singleton instance = new Singleton();
    }

    public static Singleton getInstance() {
        return Handler.instance;
    }
}
```

#### 饿汉式

等不及，一开始加载时就要创建，但这样的好处就是启动时就创建一般不会遇到线程安全问题，也就不用加锁：

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton (){}

    public static Singleton getInstance() {
        return instance;
    }
}
```

#### 枚举

以上方法都有一个缺点，就是当使用反射可以创建其对象：

```java
public class Main {
    public static void main(String[] args) {
        try {
            Class<?> clazz = Singleton.class;
            Constructor<?> constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            Singleton instance = constructor.newInstance();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
```

想要避免这种情况就需要使用枚举类实现，枚举类第一次加载时便会执行构造函数创建实例，因为构造方法是私有的，并且无法通过`new`创建新的实例，如下：

```java
public enum Singleton {
    INSTANCE;    
}
```

但是该方法也有其局限性，枚举类不能继承，只能实现接口，并且是`final`的，无法被其他类继承，那么其扩展性就受到了限制。并且创建时机并不是在`getInstance()`时，而是使用到该枚举类，枚举类第一次加载时就创建，所以不是懒汉式。

### 原型模式

用于创建重复对象，和工厂模式区别在于，工厂模式主要是根据条件或类型动态创建对象，原型模式是通过复制现有对象，创建新对象。在Java中只需要实现`Cloneable`接口实现其`clone()`方法即可。这种拷贝方式是深拷贝。

主要用于对象初始化成本高，比如复制图片、配置文件。需要通过克隆快速生成相似对象，然后修改部分属性。

### 建造者模式

分离构建过程和表示，即分步构建复杂对象，通过不同的建造者(Builder)定义不同的构建步骤，而导演类(Director)控制整个构建流程，最终生成不同表现形式的复杂对象。于是该模式需要以下几个角色：
- 抽象建造者(Builder)：定义构建对象的接口，包含初始化方法和各个部件的构建方法(比如`buildPartA()`)
- 具体建造者(ConcreteBuilder)：实现抽象建造者接口，定义具体的构建逻辑和步骤
- 产品(Product)：最终产物，包含多个组成部分(类似于主机有不同的部件)
- 导演类(Director)：调用具体建造者的方法，按照顺序执行构建步骤，隔离客户端与建造过程的细节

以下以建造房子`Home`为例。

产品：

```java
public class House {
    private String foundation;
    private String walls;
    private String roof;

    // 省略 getter setter
}
```

抽象建造者：

```java
public abstract class HouseBuilder {
    protected House house = new House();

    // 选择初始化方法
    public abstract void buildFoundation();
    public abstract void buildWalls();
    public abstract void buildRootf();

    // 返回产品
    public House getResult() {
        return house;
    }
}
```

具体建造者，比如房子有很多种类型，木屋、砖房等：

```java
public class WoodenHouseBuilder extends HouseBuilder {
    @Override
    public void buildFoundation() {
        house.foundation = "Wooden foundation";
    }

    @Override
    public void buildWalls() {
        house.walls = "Wooden walls with insulation";
    }

    @Override
    public void buildRoof() {
        house.roof = "Slate roof";
    }
}
```

```java
public class BrickHouseBuilder extends HouseBuilder {
    @Override
    public void buildFoundation() {
        house.foundation = "Concrete foundation";
    }

    @Override
    public void buildWalls() {
        house.walls = "Brick walls with mortar";
    }

    @Override
    public void buildRoof() {
        house.roof = "Red tiled roof";
    }
}
```

导演类：

```java
public class HouseDirector {
    private HouseBuilder builder;

    public HouseDirector(HouseBuilder builder) {
        this.builder = builder;
    }

    public House constructHouse() {
        builder.buildFoundation();
        builder.buildWalls();
        builder.buildRoof();
        return builder.getResult();
    }
}
```

最终客户端使用时，只需要传入具体建造者参数创建`Director`然后调用`constructHouse()`方法即可创建“产品”。当然以上方式我们可以发现流程太过单一，即只会使用一个建造者生产产品。如下：

```java
public abstract class NodeBuilder {
    protected Node node = new Node();

    public abstract void buildeValue();
    public abstract void buildeChildren(NodeBuilder childBuilder);

    public Node getResult() {
        return node;
    }
}
```

```java
public class TextNodeBuilder extends NodeBuilder {
    @Override
    public void buildValue() { node.value = "Hello World"; }
    @Override
    public void buildChildren(NodeBuilder childBuilder) {} // 无子节点
}
```

比如MyBatis构建`SqlSessionFactory`时，读取XML文件中经常会有嵌套结构比如`<mappers>`包含多个`<mapper>`，每个`<mapper>`又可能包含了`<resultMap>`、`<sqlFragment>`等，解析这些结构时，MyBatis使用递归下降解析器逐步构建配置对象。
