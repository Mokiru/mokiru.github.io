---
title: JVM垃圾收集器
date: 2025-08-16 10:00:00 +0800
categories: [Java, JVM]
tags: [study]     # TAG names should always be lowercase
author: momochi
description: 介绍JVM的几种常见垃圾收集器
comments: true # 评论
pin: false # top 
math: true
toc: true
content: true
---

## 经典垃圾收集器

Java虚拟机规范中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都可能会有很大差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。

下图展示七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。

![alt text](/assets/img/jvm/HotSpot虚拟机垃圾收集器.png)

没有“万能”的收集器，只能对具体应用选择最适合的收集器。

### Serial收集器

Serial收集器是最基础、历史最悠久的收集器，曾经(JDK1.3.1之前)是HotSpot虚拟机新生代收集器的唯一选择。从名字就能猜到，这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。“Stop The World”这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。下图为Serial/Serial Old收集器运行过程：

![alt text](/assets/img/jvm/Serial运行示意图.png)

从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep(CMS)和Garbage First(G1)收集器，Shenandoah和ZGC等，越来越优秀、复杂的垃圾收集器不断涌现，用户线程的停顿时间在持续缩短，但是仍然没有办法彻底消除。

Serial收集器依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单高效(与其他收集器的单线程相比)，对于内存资源受限的环境，它是所有收集器里额外内存消耗(保证垃圾收集能够顺利高效地进行而存储的额外信息)最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户桌面的应用场景以及部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十MB甚至几百MB的新生代(仅仅指新生代使用的内存，桌面应用很少超过这个容量)，垃圾收集的停顿时间完全2可以控制在十几、几十毫秒，最多一百毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以，Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

### ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数(例如:`-XX:SurvivorRatio -XX:PretenureSizeThreshold -XX:HandlePromotionFailure`等)、收集算法、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下图：

![alt text](/assets/img/jvm/ParNew收集器工作过程图.png)

ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行在服务端模式下的HotSpot虚拟机垃圾收集器，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。

在JDK 5发布时，HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器——CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程(基本上)同时工作。

但是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作(Parallel Scavenge收集器及G1等都没有使用HotSpot中原本设计的垃圾收集器的分代框架，Serial、ParNew则共用了这部分的框架代码)，所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器是激活CMS后(使用`-XX:+UseConcMarkSweepGC`选项)的默认新生代收集器，也可以使用`-XX:+/-UseParNewGC`选项来强制指定或者禁用它。

可以说直到CMS的出现才巩固了ParNew的地位，但随着垃圾收集器技术的不断改进，更先进的G1收集器出现了。G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作，所以自JDK 9开始，ParNew+CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1取代，甚至还取消了ParNew+Serial Old以及Serial+CMS这两组收集器组合的支持，并直接取消了`-XX:+UseParNewGC`参数，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。也可以理解成ParNew合并入CMS，成为它专门处理新生代的组成部分。

ParNew收集器再单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程(Hyper-Threading)技术实现的伪双核处理器环境中都不能百分百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多的环境中，可以使用`-XX:ParallelGCThreads`参数来限制垃圾收集的线程数。

### Parallel Scavenge收集器

Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢？

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值：

$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
$$


